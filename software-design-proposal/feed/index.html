<?xml version="1.0" encoding="UTF-8"?><rss
version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
> <channel><title>Comments on: A software design principle: Don&#8217;t make me use your design</title> <atom:link href="http://blog.biicode.com/software-design-proposal/feed/" rel="self" type="application/rss+xml" /><link>http://blog.biicode.com/software-design-proposal/</link> <description>Almost daily C and C++ jibby jabba</description> <lastBuildDate>Wed, 16 Sep 2015 03:33:00 +0000</lastBuildDate> <sy:updatePeriod>hourly</sy:updatePeriod> <sy:updateFrequency>1</sy:updateFrequency> <generator>http://wordpress.org/?v=4.2.5</generator> <item><title>By: Serge Pavlovsky</title><link>http://blog.biicode.com/software-design-proposal/#comment-164</link> <dc:creator><![CDATA[Serge Pavlovsky]]></dc:creator> <pubDate>Wed, 24 Dec 2014 13:37:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=1862#comment-164</guid> <description><![CDATA[you can write toy serialport class for use in toy program. asio is for real programs, and they already use asio anyway.]]></description> <content:encoded><![CDATA[<p>you can write toy serialport class for use in toy program. asio is for real programs, and they already use asio anyway.</p> ]]></content:encoded> </item> <item><title>By: Diego</title><link>http://blog.biicode.com/software-design-proposal/#comment-160</link> <dc:creator><![CDATA[Diego]]></dc:creator> <pubDate>Sun, 21 Dec 2014 00:14:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=1862#comment-160</guid> <description><![CDATA[I agree with the strings issues, not that much about the STL,  but I would say that overall we mostly agree: It is necessary to have and to talk about these principles, even if it can be hard to apply them in practice many times. C++ can have some complexities, but I believe that the C++ community can definitely improve, things are getting much better with the latest standards. And I think things are not always black or white, so thinking about the problems and trying to improve the existing approaches is what at the end, slowly gets us out those hells; so thanks very much for your interesting contribution to this discussion.]]></description> <content:encoded><![CDATA[<p>I agree with the strings issues, not that much about the STL,  but I would say that overall we mostly agree: It is necessary to have and to talk about these principles, even if it can be hard to apply them in practice many times. C++ can have some complexities, but I believe that the C++ community can definitely improve, things are getting much better with the latest standards. And I think things are not always black or white, so thinking about the problems and trying to improve the existing approaches is what at the end, slowly gets us out those hells; so thanks very much for your interesting contribution to this discussion.</p> ]]></content:encoded> </item> <item><title>By: Steve Wolf</title><link>http://blog.biicode.com/software-design-proposal/#comment-159</link> <dc:creator><![CDATA[Steve Wolf]]></dc:creator> <pubDate>Fri, 19 Dec 2014 16:32:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=1862#comment-159</guid> <description><![CDATA[I appreciate your goal.  It is laudable, and I strive for it, as I think many others do.
That said... I feel deeply defeated by C++.  Hell, I can&#039;t even deal with a string of text in a manner that lends itself to decoupled algorithms well.  The truth (in my experience) is that the lowly string comes in so many different flavors, and all of them have idiosyncrasies, leading to software that ends up having multiple string libraries linked in.
In my world, we have std::string, char*, TCHAR*, wchar_t*, CStringA, CStringW, BSTR, and a few lesser representations, and that doesn&#039;t even account for the fact that some are represented as UTF-8 or UTF-16LE or local code page ANSI and on &amp; on.
Again - avoiding _gratuitous_ coupling is laudable.  Trying to get truly decoupled algorithms is often impossible - compromises are the black-flies of my daily programming life.  They crop up everywhere and multiply incessantly.  Because the common ground is still too weak, and C++ doesn&#039;t handle genuinely decoupled algorithms (though it&#039;s not black and white, and I agree you can do what you can to strive towards that goal).
But even in the case of a serial port interface - you don&#039;t have to take asio, but you then limit yourself to something less general.  You&#039;re now tightly coupled to one OS&#039;s serial I/O, such as Windows API.  And you don&#039;t dove-tail as nicely with other interfaces that are designed around asio.  (I&#039;m not particular to asio, just saying that things tend to work within domains to inter-operate, and it is because of C++ lack of good standard domain that we have this mess - python has a far more robust core library / language support for abstraction across platforms and good basic types, so doesn&#039;t run into 25x string implementations or huge platform-independence libraries coming along for the serial-io ride).
Call me jaded.  I wish this were a lot easier in practice to accomplish.  Personally, I hate the std libraries approach to decoupling, because it fails.  distance() is a fine example: you&#039;re limited to using &quot;decoupled&quot; algorithms against a tight subset of actual implementation types or else your performance goes into the crapper.  std::vector will give you excellent performance there, but std::map won&#039;t.  I would have preferred a more tightly coupled sort(container) where its algorithm was tailored to the actual container&#039;s implementation so that it could give you best-case performance in all cases, rather than pushing onto the programmer hidden requirements about performance characteristics that you cannot see in the code-as-written.
Sorry, maybe this is getting dense with assumptions about how much I know or you know about how things work - but for my 2 cents - I think the STL approach was a flawed exercise by an academic mind-set, and ultimately has saddled C++ with a terrible standard.]]></description> <content:encoded><![CDATA[<p>I appreciate your goal.  It is laudable, and I strive for it, as I think many others do.<br
/> That said&#8230; I feel deeply defeated by C++.  Hell, I can&#8217;t even deal with a string of text in a manner that lends itself to decoupled algorithms well.  The truth (in my experience) is that the lowly string comes in so many different flavors, and all of them have idiosyncrasies, leading to software that ends up having multiple string libraries linked in.<br
/> In my world, we have std::string, char*, TCHAR*, wchar_t*, CStringA, CStringW, BSTR, and a few lesser representations, and that doesn&#8217;t even account for the fact that some are represented as UTF-8 or UTF-16LE or local code page ANSI and on &amp; on.<br
/> Again &#8211; avoiding _gratuitous_ coupling is laudable.  Trying to get truly decoupled algorithms is often impossible &#8211; compromises are the black-flies of my daily programming life.  They crop up everywhere and multiply incessantly.  Because the common ground is still too weak, and C++ doesn&#8217;t handle genuinely decoupled algorithms (though it&#8217;s not black and white, and I agree you can do what you can to strive towards that goal).</p><p>But even in the case of a serial port interface &#8211; you don&#8217;t have to take asio, but you then limit yourself to something less general.  You&#8217;re now tightly coupled to one OS&#8217;s serial I/O, such as Windows API.  And you don&#8217;t dove-tail as nicely with other interfaces that are designed around asio.  (I&#8217;m not particular to asio, just saying that things tend to work within domains to inter-operate, and it is because of C++ lack of good standard domain that we have this mess &#8211; python has a far more robust core library / language support for abstraction across platforms and good basic types, so doesn&#8217;t run into 25x string implementations or huge platform-independence libraries coming along for the serial-io ride).</p><p>Call me jaded.  I wish this were a lot easier in practice to accomplish.  Personally, I hate the std libraries approach to decoupling, because it fails.  distance() is a fine example: you&#8217;re limited to using &#8220;decoupled&#8221; algorithms against a tight subset of actual implementation types or else your performance goes into the crapper.  std::vector will give you excellent performance there, but std::map won&#8217;t.  I would have preferred a more tightly coupled sort(container) where its algorithm was tailored to the actual container&#8217;s implementation so that it could give you best-case performance in all cases, rather than pushing onto the programmer hidden requirements about performance characteristics that you cannot see in the code-as-written.</p><p>Sorry, maybe this is getting dense with assumptions about how much I know or you know about how things work &#8211; but for my 2 cents &#8211; I think the STL approach was a flawed exercise by an academic mind-set, and ultimately has saddled C++ with a terrible standard.</p> ]]></content:encoded> </item> <item><title>By: Diego</title><link>http://blog.biicode.com/software-design-proposal/#comment-156</link> <dc:creator><![CDATA[Diego]]></dc:creator> <pubDate>Thu, 18 Dec 2014 22:25:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=1862#comment-156</guid> <description><![CDATA[Sure, the example about Point2D is an extreme pedagogical simplification, normally, you should rely on it in normal SW engineering.
But the idea is still valid, you certainly do not need Asio (and its boost dependencies) to be able to send a few bytes over the serial port. Python pyserial is a great example, just a few files (at the end, they are also C!!!) that make a perfect, simple and modular level of abstraction over a HW serial port, not coupled with any asynchronous framework. There is nothing in C/C++ that disallows such modularity.
Of course it is no sense to break down everything to primitive parameters, but there are many situations where it is extremely simple to introduce such an intermediate layer of abstraction, and benefit from the lower coupling. The presented Point2D - distance is a prototypical example: DataModel - Algorithm, when both tend to become complex. It might become more obvious with the STL, it is exactly the same principle we are applying:
The way to decouple both is to introduce such a &quot;primitivization&quot; of the parameters. If you have a std::vector (our Point2D), and you want to std::sort (our distance) it, then:
std::sort (v.begin(), v.end());
std::sort implements a functionality very decoupled of the actual vector design. So decoupled that allows to sort also other containers. Nothing impedes to write a simple wrapper of the form mysort(v) to do exactly the same. My thesis is that this can and should be done more often that we are currently doing, we are many times doing mysort(v)  distance(p1, p2) as the only design, but many many times, especially if Point2D couples with a large hiearchy of templates, serialization, maybe even visualization (I have seen it many times), then it is very necessary (assuming that the distance function is large and complex) to decouple at some point, as defining distance(p1.x, p1.y, p2.x, p2.y), and then a wrapper distance(p1, p2) that just uses the other. Otherwise, you will soon find that you need to compute distances onboard without display, in a very similar application, and you will not be able to use what you have done in your distance function, because it is coupled with your Point2D design (as visualization!) unnecesarily.]]></description> <content:encoded><![CDATA[<p>Sure, the example about Point2D is an extreme pedagogical simplification, normally, you should rely on it in normal SW engineering.</p><p>But the idea is still valid, you certainly do not need Asio (and its boost dependencies) to be able to send a few bytes over the serial port. Python pyserial is a great example, just a few files (at the end, they are also C!!!) that make a perfect, simple and modular level of abstraction over a HW serial port, not coupled with any asynchronous framework. There is nothing in C/C++ that disallows such modularity.</p><p>Of course it is no sense to break down everything to primitive parameters, but there are many situations where it is extremely simple to introduce such an intermediate layer of abstraction, and benefit from the lower coupling. The presented Point2D &#8211; distance is a prototypical example: DataModel &#8211; Algorithm, when both tend to become complex. It might become more obvious with the STL, it is exactly the same principle we are applying:</p><p>The way to decouple both is to introduce such a &#8220;primitivization&#8221; of the parameters. If you have a std::vector (our Point2D), and you want to std::sort (our distance) it, then:</p><p>std::sort (v.begin(), v.end());</p><p>std::sort implements a functionality very decoupled of the actual vector design. So decoupled that allows to sort also other containers. Nothing impedes to write a simple wrapper of the form mysort(v) to do exactly the same. My thesis is that this can and should be done more often that we are currently doing, we are many times doing mysort(v)  distance(p1, p2) as the only design, but many many times, especially if Point2D couples with a large hiearchy of templates, serialization, maybe even visualization (I have seen it many times), then it is very necessary (assuming that the distance function is large and complex) to decouple at some point, as defining distance(p1.x, p1.y, p2.x, p2.y), and then a wrapper distance(p1, p2) that just uses the other. Otherwise, you will soon find that you need to compute distances onboard without display, in a very similar application, and you will not be able to use what you have done in your distance function, because it is coupled with your Point2D design (as visualization!) unnecesarily.</p> ]]></content:encoded> </item> <item><title>By: Steve Wolf</title><link>http://blog.biicode.com/software-design-proposal/#comment-154</link> <dc:creator><![CDATA[Steve Wolf]]></dc:creator> <pubDate>Wed, 17 Dec 2014 22:47:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=1862#comment-154</guid> <description><![CDATA[Not possible for any code that is more than a little complex - and if it were only a little complex, you wouldn&#039;t need to go get a library to help you manage it, or to have it written for you.
The reality is that to write SerialPort, you have to sit on top of something - the OS specific APIs, or a language abstraction.  C++ doesn&#039;t have a good language abstraction for I/O - not disk i/o, not serial i/o.  Don&#039;t get me wrong: it has abstractions / language support - but its support is crufty at best, and needs some additional layers to make it sane (such as asio).
Your own example of &#039;distance&#039; function - that uses Point2D.  That is a good interface.  It *should* rely on Point2D - breaking everything down to char* and float (or double?) is a terrible idea.  It drops what can be expressed down to a really lame crufty level of language-only support.  And in C/C++, that level is terrible.  Until you add things like asio and Point2D and so on, C++ is manual labor and does not lend itself to reducing work or solving problems.
Does this suck?  Yes.  But that&#039;s at the core of C++.  Unless it is going to get really good core libraries, and finally solve platform-independent I/O, graphics I/O, windowing, GUI events, etc., it will always be mired in this exact issue: to make anything genuinely useful and expressive - you&#039;re going to have drag a whole bunch of enabling libraries with your own library.  I&#039;m sorry. :(]]></description> <content:encoded><![CDATA[<p>Not possible for any code that is more than a little complex &#8211; and if it were only a little complex, you wouldn&#8217;t need to go get a library to help you manage it, or to have it written for you.</p><p>The reality is that to write SerialPort, you have to sit on top of something &#8211; the OS specific APIs, or a language abstraction.  C++ doesn&#8217;t have a good language abstraction for I/O &#8211; not disk i/o, not serial i/o.  Don&#8217;t get me wrong: it has abstractions / language support &#8211; but its support is crufty at best, and needs some additional layers to make it sane (such as asio).</p><p>Your own example of &#8216;distance&#8217; function &#8211; that uses Point2D.  That is a good interface.  It *should* rely on Point2D &#8211; breaking everything down to char* and float (or double?) is a terrible idea.  It drops what can be expressed down to a really lame crufty level of language-only support.  And in C/C++, that level is terrible.  Until you add things like asio and Point2D and so on, C++ is manual labor and does not lend itself to reducing work or solving problems.</p><p>Does this suck?  Yes.  But that&#8217;s at the core of C++.  Unless it is going to get really good core libraries, and finally solve platform-independent I/O, graphics I/O, windowing, GUI events, etc., it will always be mired in this exact issue: to make anything genuinely useful and expressive &#8211; you&#8217;re going to have drag a whole bunch of enabling libraries with your own library.  I&#8217;m sorry. :(</p> ]]></content:encoded> </item> <item><title>By: Craig Brandenburg</title><link>http://blog.biicode.com/software-design-proposal/#comment-149</link> <dc:creator><![CDATA[Craig Brandenburg]]></dc:creator> <pubDate>Tue, 02 Dec 2014 02:20:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=1862#comment-149</guid> <description><![CDATA[Yet another way of saying it: Make tools, not frameworks.]]></description> <content:encoded><![CDATA[<p>Yet another way of saying it: Make tools, not frameworks.</p> ]]></content:encoded> </item> <item><title>By: Diego</title><link>http://blog.biicode.com/software-design-proposal/#comment-147</link> <dc:creator><![CDATA[Diego]]></dc:creator> <pubDate>Sat, 29 Nov 2014 19:11:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=1862#comment-147</guid> <description><![CDATA[Yes, very, very related, but not only. Also related to coupling. A very simplified example:.
float distance(Point2D p1, Point2D p2){return sqrt((pow(p2.x-p1.x,2)+pow(p2.y-p1.y, 2);}
It clearly has a Single Responsibility, but it is still coupled with a design (Point2D, which typically could be an instatiation of Point... and so on...).
float distance(float x1, float y1, float x2, float y2);
is not.
Obviously not the best solution for this simple example, but if the distance algorithm had 100 lines long, IMHO it is better to code it as independent as possible of your current project types and classes, then build an adaptor/wrapper to it for your project.]]></description> <content:encoded><![CDATA[<p>Yes, very, very related, but not only. Also related to coupling. A very simplified example:.</p><p>float distance(Point2D p1, Point2D p2){return sqrt((pow(p2.x-p1.x,2)+pow(p2.y-p1.y, 2);}</p><p>It clearly has a Single Responsibility, but it is still coupled with a design (Point2D, which typically could be an instatiation of Point&#8230; and so on&#8230;).</p><p>float distance(float x1, float y1, float x2, float y2);</p><p>is not.</p><p>Obviously not the best solution for this simple example, but if the distance algorithm had 100 lines long, IMHO it is better to code it as independent as possible of your current project types and classes, then build an adaptor/wrapper to it for your project.</p> ]]></content:encoded> </item> <item><title>By: Rob Grainger</title><link>http://blog.biicode.com/software-design-proposal/#comment-145</link> <dc:creator><![CDATA[Rob Grainger]]></dc:creator> <pubDate>Sat, 29 Nov 2014 00:02:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=1862#comment-145</guid> <description><![CDATA[It&#039;s all really just an application of the Single Responsibility Principle. The serial port class should be responsible for access to a serial port, not making the serial port appear as a stream.]]></description> <content:encoded><![CDATA[<p>It&#8217;s all really just an application of the Single Responsibility Principle. The serial port class should be responsible for access to a serial port, not making the serial port appear as a stream.</p> ]]></content:encoded> </item> <item><title>By: Visto nel Web &#8211; 155 &#124; Ok, panico</title><link>http://blog.biicode.com/software-design-proposal/#comment-131</link> <dc:creator><![CDATA[Visto nel Web &#8211; 155 &#124; Ok, panico]]></dc:creator> <pubDate>Sun, 02 Nov 2014 08:54:51 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=1862#comment-131</guid> <description><![CDATA[[&#8230;] A software design principle: Don’t make me use your design ::: biicode [&#8230;]]]></description> <content:encoded><![CDATA[<p>[&#8230;] A software design principle: Don’t make me use your design ::: biicode [&#8230;]</p> ]]></content:encoded> </item> </channel> </rss>