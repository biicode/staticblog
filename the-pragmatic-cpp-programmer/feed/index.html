<?xml version="1.0" encoding="UTF-8"?><rss
version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
> <channel><title>Comments on: The Pragmatic C++ Programmer</title> <atom:link href="http://blog.biicode.com/the-pragmatic-cpp-programmer/feed/" rel="self" type="application/rss+xml" /><link>http://blog.biicode.com/the-pragmatic-cpp-programmer/</link> <description>Almost daily C and C++ jibby jabba</description> <lastBuildDate>Wed, 16 Sep 2015 03:33:00 +0000</lastBuildDate> <sy:updatePeriod>hourly</sy:updatePeriod> <sy:updateFrequency>1</sy:updateFrequency> <generator>http://wordpress.org/?v=4.2.5</generator> <item><title>By: LUG дайджест #12 &#124; LUG Udmurtia</title><link>http://blog.biicode.com/the-pragmatic-cpp-programmer/#comment-258</link> <dc:creator><![CDATA[LUG дайджест #12 &#124; LUG Udmurtia]]></dc:creator> <pubDate>Mon, 25 May 2015 09:16:09 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=2242#comment-258</guid> <description><![CDATA[[&#8230;] libraries we use &#8212; Free C++ Books &#8212; Writing a basic clang static analysis check &#8212; The Pragmatic C++ Programmer &#8212; Deploying A Scientific Python Environment &#8212; Free software testing [&#8230;]]]></description> <content:encoded><![CDATA[<p>[&#8230;] libraries we use &#8212; Free C++ Books &#8212; Writing a basic clang static analysis check &#8212; The Pragmatic C++ Programmer &#8212; Deploying A Scientific Python Environment &#8212; Free software testing [&#8230;]</p> ]]></content:encoded> </item> <item><title>By: Collin Rogowski</title><link>http://blog.biicode.com/the-pragmatic-cpp-programmer/#comment-255</link> <dc:creator><![CDATA[Collin Rogowski]]></dc:creator> <pubDate>Tue, 19 May 2015 06:32:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=2242#comment-255</guid> <description><![CDATA[Thx a lot. I read up on move semantics (didn&#039;t know it beforehand). It seems C++11 is actually quite different from the old C++. This is gonna take a while to get ingrained... :-)]]></description> <content:encoded><![CDATA[<p>Thx a lot. I read up on move semantics (didn&#8217;t know it beforehand). It seems C++11 is actually quite different from the old C++. This is gonna take a while to get ingrained&#8230; :-)</p> ]]></content:encoded> </item> <item><title>By: Nikesh Singh Tanwer</title><link>http://blog.biicode.com/the-pragmatic-cpp-programmer/#comment-254</link> <dc:creator><![CDATA[Nikesh Singh Tanwer]]></dc:creator> <pubDate>Sun, 17 May 2015 05:11:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=2242#comment-254</guid> <description><![CDATA[Any Suggestion for newbie in C++, from where i should start learning C++, so that i will not do this kind of mistakes ?]]></description> <content:encoded><![CDATA[<p>Any Suggestion for newbie in C++, from where i should start learning C++, so that i will not do this kind of mistakes ?</p> ]]></content:encoded> </item> <item><title>By: Liquidify</title><link>http://blog.biicode.com/the-pragmatic-cpp-programmer/#comment-252</link> <dc:creator><![CDATA[Liquidify]]></dc:creator> <pubDate>Fri, 15 May 2015 06:45:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=2242#comment-252</guid> <description><![CDATA[Any advice for a complete noob to C++ coming from a very light python background?  What are the first books and steps I should be taking?]]></description> <content:encoded><![CDATA[<p>Any advice for a complete noob to C++ coming from a very light python background?  What are the first books and steps I should be taking?</p> ]]></content:encoded> </item> <item><title>By: Brad Serbu</title><link>http://blog.biicode.com/the-pragmatic-cpp-programmer/#comment-250</link> <dc:creator><![CDATA[Brad Serbu]]></dc:creator> <pubDate>Wed, 13 May 2015 18:24:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=2242#comment-250</guid> <description><![CDATA[Thanks.  I thought you were reffering to Java code.  It&#039;s clear to me now the term &quot;Java++&quot; = C++ code written like it was Java - i.e. the example of your teacher.]]></description> <content:encoded><![CDATA[<p>Thanks.  I thought you were reffering to Java code.  It&#8217;s clear to me now the term &#8220;Java++&#8221; = C++ code written like it was Java &#8211; i.e. the example of your teacher.</p> ]]></content:encoded> </item> <item><title>By: Manu343726</title><link>http://blog.biicode.com/the-pragmatic-cpp-programmer/#comment-249</link> <dc:creator><![CDATA[Manu343726]]></dc:creator> <pubDate>Wed, 13 May 2015 17:49:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=2242#comment-249</guid> <description><![CDATA[&gt; Are you using Java++ as a tongue and cheek reference to Java?
Yep, that&#039;s how I refer to that code that&#039;s supposed to be C++ since they are compiling with a C++ compiler, but has more to do with Java idioms and related.]]></description> <content:encoded><![CDATA[<p>&gt; Are you using Java++ as a tongue and cheek reference to Java?</p><p>Yep, that&#8217;s how I refer to that code that&#8217;s supposed to be C++ since they are compiling with a C++ compiler, but has more to do with Java idioms and related.</p> ]]></content:encoded> </item> <item><title>By: Manu343726</title><link>http://blog.biicode.com/the-pragmatic-cpp-programmer/#comment-248</link> <dc:creator><![CDATA[Manu343726]]></dc:creator> <pubDate>Wed, 13 May 2015 17:47:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=2242#comment-248</guid> <description><![CDATA[I think that @MaxGalkin summarizes it pretty well: http://yacoder.net/blog/2015/04/26/cpp-curiosities-move-semantics-sizeof-areaof-and-pointy-types/
The point is that C++ objects come primarily from two categories:
- Values
- Resource handlers
The former identify those classes that are a pure aggregation of values, think of `std::complex` or a proper `vector2d` implementation instead of the monstrosity above. This classes allocate all data they manage directly on the same location (Stack, heap, whatever) the object lives, and that data is directly part of object&#039;s memory. As you can see, there&#039;s no point on allocating an object of such category on the heap if you are playing on the stack. Since sizeof(x) == areaof(x) C++11 move semantics do not add any performance difference.
The latter are those classes that manages a resource that, needs to be allocated at runtime (Dynamic array etc), or is a resource not managed directly by the language (A file handle, for example). In this cases, not all data managed by the object is part of object data, but referenced by one or more of its members. Even if that&#039;s the case, **the object can still live on the stack, and there&#039;s no reason to dynamically allocate the object**. As Max says on the article, move semantics worth it if sizeof(T) &lt;&lt; areaof(T) so there&#039;s a difference between swapping the handles and copying the data that handles refer to.
Most huge objects are really objects with big areaof() but not sizeof(), that is, when an object manages large chunks of data it usually does externally to the object itself. We have good examples in the standard library, such as vector, string, map, etc.
So my answer is: Since C++11 the language has proper semantics to handle &quot;resource bypassing&quot;: Move semantics means that you are able to differentiate when a resource is being passed to another context (object), instead of wasting time copying the resource into the new context and then delete the original (now dead) resource.
The only true reason you might want dynamic allocation of objects is to share them between multiple contexts, and that&#039;s exactly what std::shared_ptr (A resource handler ready for that purpose) is supposed to do. As you can see, you can avoid new/delete/naked-ptrs completely in modern c++.]]></description> <content:encoded><![CDATA[<p>I think that @MaxGalkin summarizes it pretty well: <a
href="http://yacoder.net/blog/2015/04/26/cpp-curiosities-move-semantics-sizeof-areaof-and-pointy-types/" rel="nofollow">http://yacoder.net/blog/2015/04/26/cpp-curiosities-move-semantics-sizeof-areaof-and-pointy-types/</a></p><p>The point is that C++ objects come primarily from two categories:</p><p> &#8211; Values<br
/> &#8211; Resource handlers</p><p>The former identify those classes that are a pure aggregation of values, think of <code>std::complex</code> or a proper <code>vector2d</code> implementation instead of the monstrosity above. This classes allocate all data they manage directly on the same location (Stack, heap, whatever) the object lives, and that data is directly part of object&#8217;s memory. As you can see, there&#8217;s no point on allocating an object of such category on the heap if you are playing on the stack. Since sizeof(x) == areaof(x) C++11 move semantics do not add any performance difference.</p><p>The latter are those classes that manages a resource that, needs to be allocated at runtime (Dynamic array etc), or is a resource not managed directly by the language (A file handle, for example). In this cases, not all data managed by the object is part of object data, but referenced by one or more of its members. Even if that&#8217;s the case, **the object can still live on the stack, and there&#8217;s no reason to dynamically allocate the object**. As Max says on the article, move semantics worth it if sizeof(T) &lt;&lt; areaof(T) so there&#039;s a difference between swapping the handles and copying the data that handles refer to.</p><p>Most huge objects are really objects with big areaof() but not sizeof(), that is, when an object manages large chunks of data it usually does externally to the object itself. We have good examples in the standard library, such as vector, string, map, etc.</p><p>So my answer is: Since C++11 the language has proper semantics to handle &quot;resource bypassing&quot;: Move semantics means that you are able to differentiate when a resource is being passed to another context (object), instead of wasting time copying the resource into the new context and then delete the original (now dead) resource.<br
/> The only true reason you might want dynamic allocation of objects is to share them between multiple contexts, and that&#039;s exactly what std::shared_ptr (A resource handler ready for that purpose) is supposed to do. As you can see, you can avoid new/delete/naked-ptrs completely in modern c++.</p> ]]></content:encoded> </item> <item><title>By: Brad Serbu</title><link>http://blog.biicode.com/the-pragmatic-cpp-programmer/#comment-247</link> <dc:creator><![CDATA[Brad Serbu]]></dc:creator> <pubDate>Wed, 13 May 2015 15:45:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=2242#comment-247</guid> <description><![CDATA[Are you using Java++ as a tongue and cheek reference to Java?
Is it an idiomatic term used in other communities/forums/chatrooms/posts that I&#039;m not familiar with?
Loved the article and the use of that term in no way detracted from the comprehension of it, but I can&#039;t help but wonder the intent behind the usage of the term.
Cheers.]]></description> <content:encoded><![CDATA[<p>Are you using Java++ as a tongue and cheek reference to Java?<br
/> Is it an idiomatic term used in other communities/forums/chatrooms/posts that I&#8217;m not familiar with?</p><p>Loved the article and the use of that term in no way detracted from the comprehension of it, but I can&#8217;t help but wonder the intent behind the usage of the term.</p><p>Cheers.</p> ]]></content:encoded> </item> <item><title>By: Collin Rogowski</title><link>http://blog.biicode.com/the-pragmatic-cpp-programmer/#comment-246</link> <dc:creator><![CDATA[Collin Rogowski]]></dc:creator> <pubDate>Wed, 13 May 2015 09:34:00 +0000</pubDate> <guid
isPermaLink="false">http://blog.biicode.com/?p=2242#comment-246</guid> <description><![CDATA[Interesting article, although it could have been a little bit less &quot;ranty&quot; for my taste. ;-)
When I started working with C++ coming from a Java Background a did the same thing you described and worked only with pointers to objects and not with objects. Until it hit me that this was not the way to go :-)
What I find the most difficult while (still) learning this, is that the decision to switch from objects on the stack to objects on the heap depends on the size of the object. So if I work incrementally (starting with a small class which gets bigger and bigger as my program grows), I suddenly have to switch from objects to pointers... And that&#039;s a lot of work. I guess you could argue that maybe you should strive to only have classes that are small enough so that this problem doesn&#039;t arise... Do you have some insights into this?]]></description> <content:encoded><![CDATA[<p>Interesting article, although it could have been a little bit less &#8220;ranty&#8221; for my taste. ;-)</p><p>When I started working with C++ coming from a Java Background a did the same thing you described and worked only with pointers to objects and not with objects. Until it hit me that this was not the way to go :-)</p><p>What I find the most difficult while (still) learning this, is that the decision to switch from objects on the stack to objects on the heap depends on the size of the object. So if I work incrementally (starting with a small class which gets bigger and bigger as my program grows), I suddenly have to switch from objects to pointers&#8230; And that&#8217;s a lot of work. I guess you could argue that maybe you should strive to only have classes that are small enough so that this problem doesn&#8217;t arise&#8230; Do you have some insights into this?</p> ]]></content:encoded> </item> </channel> </rss>