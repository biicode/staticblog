<?xml version="1.0" encoding="UTF-8"?><rss
version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:wfw="http://wellformedweb.org/CommentAPI/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
> <channel><title>biicode Blog &#187; pablo</title> <atom:link href="http://blog.biicode.com/author/pablo/feed/" rel="self" type="application/rss+xml" /><link>http://blog.biicode.com</link> <description>Almost daily C and C++ jibby jabba</description> <lastBuildDate>Sun, 16 Aug 2015 07:58:20 +0000</lastBuildDate> <language>en-US</language> <sy:updatePeriod>hourly</sy:updatePeriod> <sy:updateFrequency>1</sy:updateFrequency> <generator>http://wordpress.org/?v=4.2.5</generator> <item><title>Exact maximum clique for large or massive real graphs continued</title><link>http://blog.biicode.com/exact-maximum-clique-for-massive-real-graphs/</link> <comments>http://blog.biicode.com/exact-maximum-clique-for-massive-real-graphs/#comments</comments> <pubDate>Wed, 08 Apr 2015 09:23:34 +0000</pubDate> <dc:creator><![CDATA[pablo]]></dc:creator> <category><![CDATA[algorithms]]></category> <category><![CDATA[biicode]]></category> <category><![CDATA[BBMCSP algorithm]]></category> <category><![CDATA[Exact maximum clique]]></category> <category><![CDATA[Massive real graphs]]></category> <guid
isPermaLink="false">http://blog.biicode.com/?p=2164</guid> <description><![CDATA[<p>The excellent performance reported by BBMCSP—an exact maximum clique algorithm tailored for massive real networks— in a previous post has raised a number of comments, some even questioning either the report itself or the problem’s complexity. This post gives an insight on how BBMCSP works. In the process, and similar to what happens when magicians [&#8230;]</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/exact-maximum-clique-for-massive-real-graphs/">Exact maximum clique for large or massive real graphs continued</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></description> <content:encoded><![CDATA[<p>The excellent performance reported by BBMCSP—an exact maximum clique algorithm tailored for massive real networks— in a <a
href="http://blog.biicode.com/maximum-clique-for-massive-sparse-graphs/">previous post</a> has raised a number of comments, some even questioning either the report itself or the problem’s complexity. This post gives an insight on how BBMCSP works. In the process, and similar to what happens when magicians explain their tricks, we are aware that some of the magic will be lost.</p><p><span
id="more-2164"></span></p><p>BBMCSP’s overarching ideas are described in the pseudocode below:</p><h2><strong>BBMCSP: an exact maximum clique algorithm</strong></h2><p><em>Input</em>: A simple graph G(V, E)<br
/> <em>Output</em>: A maximum clique in G in S<sub>max</sub></p><ol><li>Compute k-core decomposition of G: K(G)</li><li>Compute an initial clique greedily: S<sub>max</sub></li><li>Remove vertices from G such that K(v)&lt;|S<sub>max</sub>|: G<sub>r </sub>(V<sub>r</sub>, E<sub>r</sub>)</li><li>Sort V<sub>r</sub> according to degeneracy</li><li>Iteratively branch on vertices in Vr in reverse order: v</li><li>|    Compute subproblem derived from v: W ⊆ V<sub>r</sub></li><li>|    Compute a greedy coloring of W : C(W). <strong>if</strong> |C(W)|&lt; |S<sub>max</sub>| <strong>return</strong></li><li>|    Compute k-core decomposition of W : K(W).<strong> if</strong> |K(W)|&lt; |S<sub>max</sub>| <strong>return</strong></li><li>|    Remove vertices w from W such that K(w)&lt;|S<sub>max</sub>|: W’</li><li>|    Sort W’ according to degeneracy</li><li>|    SEARCH for a maximum clique in W’ with BBMC sparse solver : S<sub>max</sub></li><li>|_ Remove v from V<sub>r</sub></li><li><strong>return</strong> S<sub>max</sub></li></ol><h3><strong> STEP BY STEP</strong></h3><p>All steps except 11 constitute preprocessing tailored for massive graphs. Core hierarchical decomposition in step 1 is a must for any decent graph software package. Each k-core determines a maximal subgraph with the property that all its vertices have degree at least k (cf. <a
href="http://blog.biicode.com/maximum-clique-for-massive-sparse-graphs/">previous post</a>). Thus, the core number of a vertex is the order the highest core which contains it and the core number of the graph is the order of its highest core.  Note that, in the case of real graphs, the core number is usually much lower than the maximum degree of the graph—e.g. in networks with a power law distribution only a few individuals are massively connected—. Step 3 removes vertices that cannot possibly improve the initial greedy clique in S<sub>max</sub> because of a low core number. After that vertices are sorted in step 4 according to degeneracy, i.e. non increasing core number.</p><p>Step 5 is the main loop which may be regarded as a first level unrolling of the search tree of a typical exact solver. For each vertex v picked in reverse order, the child subproblem—its neighbor set— is also preprocessed trying to produce an early cut. Step 7 is concerned with approximate color cuts, i.e. the current best solution in S<sub>max</sub> cannot be improved by any subproblem in which a coloring of size less than | S<sub>max</sub>|.  Moreover, Step 8 prunes the subproblem if its core number is less than| S<sub>max</sub>|.  Finally, if the subproblem cannot be pruned directly in the previous two steps, concrete vertices are removed when their core number is less than | S<sub>max</sub>| in step 9. Remaining vertices are sorted by degeneracy in step 10.</p><p>The actual NP-hard search occurs in step 11 over the filtered subproblem W&#8217;. BBMCSP uses the exact bitstring solver BBMC tailored for large or massive graphs by a specifically designed sparse encoding, as mentioned in the alluded <a
href="http://blog.biicode.com/maximum-clique-for-massive-sparse-graphs/">previous post</a>.</p><h3><strong>AN EXAMPLE</strong></h3><div
id="attachment_2169" style="width: 640px" class="wp-caption aligncenter"><img
class="wp-image-2169 size-large" src="http://blog.biicode.com/wp-content/uploads/sites/2/2015/04/GraphExample-1024x585.png" alt="An example of a graph being used to solve the exact maximum clique problem." width="630" height="360" /><p
class="wp-caption-text">Figure 1. A Graph example. Label notation &lt;x:y:z&gt; denotes vertex index, kcore and degree respectively</p></div><p>Figure 1 contains a simple graph G of order 10 &#8211;notation for node labels x:y:x is <em>x</em> for index, <em>y</em> for kcore number and <em>z</em> for degree&#8211;. The graph core number K(G) is 4 and its maximum degree is 6 (given by vertex 6). Step 2 of the algorithm finds an initial greedy clique | S<sub>max</sub>| of  3 so vertices 1 and 5 are explicitly removed  from G in step 3. The remaining vertices are ordered according to degeneracy in step 4 (see figure 1, left).</p><p>Figure 2 below contains the resulting behaviour of BBMCSP in the main loop (steps 5-12), which includes the first level unrolling and the actual NP-hard search. Vertices are picked in reverse order (header <em>v</em>) and, after each iteration, removed from G<sub>r </sub>. The first iteration in the loop calls vertex 8 and analyses subproblem W={2, 3, 5, 7}. The vertex coloring C(W)  has color size 3, same as   | S<sub>max</sub>| so the subproblem cannot be pruned at step 7. The subproblem <em>is </em>pruned, however, in step 8 by core analysis. Subsequently vertex 8 is removed and vertex 7 startsa new iteration (second row).</p><p>The critical step occurs when vertex 6 is chosen, which contains a maximum clique {1, 2, 4, 6}. In this case the entire subproblem cannot obviously be pruned so vertex 9 is reached and vertex 5 is removed since K(5) is lower than | S<sub>max</sub>|. The search routine is finally called in step 11 and the clique si found. Remaining vertices in G<sub>r </sub>are pruned more or less trivially thereafter.</p><div
id="attachment_2174" style="width: 838px" class="wp-caption aligncenter"><img
class="wp-image-2174" src="http://blog.biicode.com/wp-content/uploads/sites/2/2015/04/BBMCSP_search.png" alt="BBMCSP steps 5-12 taken in the exact maximum clique problem solving" width="828" height="313" /><p
class="wp-caption-text">Figure 2. BBMCSP steps 5-12</p></div><h3><strong>IMPLEMENTATION DETAILS</strong></h3><p>K-core analysis is critical during preprocessing. If the reader wants to implement it by himself we warn him that the typical solution runs in O(|V|<sup>2</sup>) which is not adequate for large or massive sparse graphs. We recommend the O(|E|) algorithm of <a
href="http://vlado.fmf.uni-lj.si/pub/networks/doc/cores/cores.pdf">Bagatelij</a>—the  implementation used by BBMCSP can be found in the <a
href="https://www.biicode.com/pablodev/graph">pablodev/graph</a> block in the Biicode repo—. A side result is that vertices are also sorted according to degeneracy, which is necessary for steps 4 and 10 as explained.</p><p>A sequential greedy coloring in step 7 assigns, to each vertex in turn, the lowest possible color label consistent with the current partial coloring. The bitstring implementation employed by BBMCSP may be found in the <a
href="https://www.biicode.com/pablodev/copt">pablodev/copt</a> block (<em>InitColor</em> class).</p><p>Additionally, the sparse encoding used by BBMC is available as part of the BITSCAN library—<a
href="https://www.biicode.com/pablodev/bitscan">pablodev/bitscan</a> block— and the GRAPH library—pablodev/graph— block. BBMCSP uses the sparse_graph available in GRAPH and currently most of the source code is also available in the pablodev/copt block.</p><h4><strong>A NOTE ON COMPLEXITY</strong></h4><p>In reply to the comments of some of our readers, maximum clique is <em>still</em> NP-hard, yes, and uniform graphs of say a thousand vertices and 0.8 density remain a very difficult challenge for today’s best exact solvers. The reason why BBMCSP is so successful lies mainly on the structure of real networks, which is typically much simplified after the heavy tailored preprocessing described.</p><p>That this is so can be seen in the following example: the California road network <em>roadNet-CA</em> with 1.9 million nodes, 2.7 million edges and a clique number of 4 was trivially solved in less than a second of preprocessing by BBMCSP—step 11, the NP-hard search step, is actually never called—. The same graph was proposed as benchmark in a recent Big Data Conference [1]. There it took 153 seconds to solve using 75 processor nodes!</p><p>Raw results of <a
href="http://venus.elai.upm.es/logs/results_sparse/bin/">BMCSP </a>against more than 200 real networks, as well as results of state-of-the-art algorithms are available <a
href="http://venus.elai.upm.es/logs/results_sparse/">here</a>. We are currently working on a heavy refactoring and a more sophisticated command line parameter interface both for Windows and Linux binaries. As always, we await comments and suggestions from readers.</p><p>&nbsp;</p><p>[1] Hagan, R. D. et al.; <em>Toward an Efficient, Highly Scalable Maximum Clique Solver for Massive Graphs</em>, IEEE Conf. on Big Data, 2014.</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/exact-maximum-clique-for-massive-real-graphs/">Exact maximum clique for large or massive real graphs continued</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></content:encoded> <wfw:commentRss>http://blog.biicode.com/exact-maximum-clique-for-massive-real-graphs/feed/</wfw:commentRss> <slash:comments>0</slash:comments> </item> <item><title>Maximum clique for massive sparse graphs</title><link>http://blog.biicode.com/maximum-clique-for-massive-sparse-graphs/</link> <comments>http://blog.biicode.com/maximum-clique-for-massive-sparse-graphs/#comments</comments> <pubDate>Tue, 24 Feb 2015 15:52:49 +0000</pubDate> <dc:creator><![CDATA[pablo]]></dc:creator> <category><![CDATA[algorithms]]></category> <category><![CDATA[BITSCAN]]></category> <guid
isPermaLink="false">http://blog.biicode.com/?p=2108</guid> <description><![CDATA[<p>In a previous post we introduced the maximum clique problem (MCP) and reported performance of the efficient bit-parallel exact solver BBMC, implemented with BITSCAN and GRAPH libraries available in the Biicode repositories pablodev/bitscan and pablodev/graph respectively. BBMC is concerned with small and middle size graphs. Also very challenging are real networks that arise from different [&#8230;]</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/maximum-clique-for-massive-sparse-graphs/">Maximum clique for massive sparse graphs</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></description> <content:encoded><![CDATA[<p>In a <a
href="http://blog.biicode.com/category/bitscan-2/">previous post</a> we introduced the maximum clique problem (MCP) and reported performance of the efficient bit-parallel exact solver BBMC, implemented with BITSCAN and GRAPH libraries available in the Biicode repositories <a
title="Bitscan" href="https://www.biicode.com/pablodev/bitscan" target="_blank">pablodev/bitscan</a> and <a
title="GRAPH" href="https://www.biicode.com/pablodev/graph" target="_blank">pablodev/graph</a> respectively. BBMC is concerned with small and middle size graphs.</p><p>Also very challenging are real networks that arise from different fields such as social networks, infrastructure networks, scientific networks and so on. These graphs tend to have many thousands—even millions— of nodes but are usually very sparse —the <a
title="Network Repository" href="http://networkrepository.com/" target="_blank">Network Data Repository</a> hosts more than 500 of such graphs—.  An open problem is finding the clique number (the cardinality of a maximum clique) of such networks to get an insight into their structure. Unfortunately the problem is NP-hard and no polynomial algorithm is expected to be found; tailoring and exact solver for this task is as yet an <a
title="Open questions on Clique" href="http://link.springer.com/chapter/10.1007%2F978-3-642-13193-6_2" target="_blank">open question</a> [1].</p><p><img
class="aligncenter" src="http://ryanrossi.com/pmc/tscc/infectious.png" alt="BBMCSP is the new application of BITSCAN and GRAPH libs available in biicode to solve the maximum clique problem." width="471" height="459" /></p><p><span
id="more-2108"></span></p><h2>BBMCSP can quickly solve the maximum clique problem of sparse networks</h2><p>Only just some months ago it has been possible to tailor BBMC for real networks. The main problem in successful exact solvers for the middle size case is that the majority of them encode the adjacency matrix in full, whereas real graphs require some form of compression—i.e. typically a list of edges—. The new BBMCSP algorithm uses the <em>sparse_graph</em> type available in GRAPH to compress the adjacency matrix, while still taking advantage of fast bit string operations between vertex sets.</p><p>As in the previous post we will not go into implementation details here —see the <a
title="COPT block" href="https://www.biicode.com/pablodev/copt" target="_blank">pablodev/copt</a> block to look at some source code—but  report performance of BBMCSP over a number of massive networks available in the Network Data Repository. Experiments have been run on a  Linux workstation with an Intel(R) Xeon(R) CPU E5-2690 v2 multi-core processor and 128GB of main memory, using always a single-core. The table reports comparison results against previous best <a
title="PMC algorithm home page" href="http://ryanrossi.com/pmc/" target="_blank">PMC </a>algorithm over 30 massive graphs. In the table each row is a network. Header <em>dmax</em> and <em>davg </em>stand for maximum graph degree and average graph degree respectively; w is the cardinality of the maximum clique, <em>BBMCSP</em> and <em>PMC</em> gives search time performance in seconds for both algorithms and <em>PMC/BBMCSP </em>reports  the time ratio.</p><table
id="tablepress-4" class="tablepress tablepress-id-4"><thead><tr
class="row-1 odd"><th
class="column-1">Category</th><th
class="column-2">Name</th><th
class="column-3">|V|</th><th
class="column-4">|E|</th><th
class="column-5">dmax</th><th
class="column-6">davg</th><th
class="column-7">w</th><th
class="column-8">BBMCSP</th><th
class="column-9">PMC</th><th
class="column-10">PMC/  BBMCSP</th></tr></thead><tbody
class="row-hover"><tr
class="row-2 even"><td
class="column-1">Affiliation</td><td
class="column-2">aff-orkut-user2groups</td><td
class="column-3">8730857</td><td
class="column-4">327037420</td><td
class="column-5">318268</td><td
class="column-6">74.92</td><td
class="column-7">6</td><td
class="column-8">1377.23</td><td
class="column-9">29042.3</td><td
class="column-10">21.09</td></tr><tr
class="row-3 odd"><td
class="column-1">Infrastructure</td><td
class="column-2">inf-germany_osm</td><td
class="column-3">11548845</td><td
class="column-4">12369181</td><td
class="column-5">13</td><td
class="column-6">2.14</td><td
class="column-7">3</td><td
class="column-8">&gt;0.001</td><td
class="column-9">2.88</td><td
class="column-10">2878.92</td></tr><tr
class="row-4 even"><td
class="column-1">Infrastructure</td><td
class="column-2">inf-great-britain_osm</td><td
class="column-3">7733822</td><td
class="column-4">8156517</td><td
class="column-5">8</td><td
class="column-6">2.11</td><td
class="column-7">3</td><td
class="column-8">&gt;0.001</td><td
class="column-9">1.94</td><td
class="column-10">1939.6</td></tr><tr
class="row-5 odd"><td
class="column-1">Infrastructure</td><td
class="column-2">inf-italy_osm</td><td
class="column-3">6686493</td><td
class="column-4">7013978</td><td
class="column-5">9</td><td
class="column-6">2.1</td><td
class="column-7">3</td><td
class="column-8">&gt;0.001</td><td
class="column-9">1.54</td><td
class="column-10">1540.19</td></tr><tr
class="row-6 even"><td
class="column-1">Scientific computing</td><td
class="column-2">adaptive</td><td
class="column-3">6815744</td><td
class="column-4">13624320</td><td
class="column-5">4</td><td
class="column-6">4</td><td
class="column-7">2</td><td
class="column-8">1.15</td><td
class="column-9">6.94</td><td
class="column-10">6.03</td></tr><tr
class="row-7 odd"><td
class="column-1">Scientific computing</td><td
class="column-2">channel-500x100x100-b050</td><td
class="column-3">4802000</td><td
class="column-4">42681372</td><td
class="column-5">18</td><td
class="column-6">17.78</td><td
class="column-7">4</td><td
class="column-8">5.22</td><td
class="column-9">21.15</td><td
class="column-10">4.06</td></tr><tr
class="row-8 even"><td
class="column-1">Scientific computing</td><td
class="column-2">delaunay_n22</td><td
class="column-3">4194304</td><td
class="column-4">12582869</td><td
class="column-5">23</td><td
class="column-6">6</td><td
class="column-7">4</td><td
class="column-8">1.58</td><td
class="column-9">7.4</td><td
class="column-10">4.7</td></tr><tr
class="row-9 odd"><td
class="column-1">Scientific computing</td><td
class="column-2">delaunay_n23</td><td
class="column-3">8388608</td><td
class="column-4">25165784</td><td
class="column-5">28</td><td
class="column-6">6</td><td
class="column-7">4</td><td
class="column-8">3.29</td><td
class="column-9">14.87</td><td
class="column-10">4.52</td></tr><tr
class="row-10 even"><td
class="column-1">Scientific computing</td><td
class="column-2">delaunay_n24</td><td
class="column-3">16777216</td><td
class="column-4">50331601</td><td
class="column-5">26</td><td
class="column-6">6</td><td
class="column-7">4</td><td
class="column-8">6.84</td><td
class="column-9">29.38</td><td
class="column-10">4.29</td></tr><tr
class="row-11 odd"><td
class="column-1">Scientific computing</td><td
class="column-2">hugebubbles-00020</td><td
class="column-3">21198119</td><td
class="column-4">31790179</td><td
class="column-5">3</td><td
class="column-6">3</td><td
class="column-7">2</td><td
class="column-8">3.62</td><td
class="column-9">34.05</td><td
class="column-10">9.4</td></tr><tr
class="row-12 even"><td
class="column-1">Scientific computing</td><td
class="column-2">hugetrace-00000</td><td
class="column-3">4588484</td><td
class="column-4">6879133</td><td
class="column-5">3</td><td
class="column-6">3</td><td
class="column-7">2</td><td
class="column-8">0.69</td><td
class="column-9">5.2</td><td
class="column-10">7.54</td></tr><tr
class="row-13 odd"><td
class="column-1">Scientific computing</td><td
class="column-2">hugetrace-00010</td><td
class="column-3">12057441</td><td
class="column-4">18082179</td><td
class="column-5">3</td><td
class="column-6">3</td><td
class="column-7">2</td><td
class="column-8">1.83</td><td
class="column-9">14.82</td><td
class="column-10">8.09</td></tr><tr
class="row-14 even"><td
class="column-1">Scientific computing</td><td
class="column-2">hugetric-00000</td><td
class="column-3">5824554</td><td
class="column-4">8733523</td><td
class="column-5">3</td><td
class="column-6">3</td><td
class="column-7">2</td><td
class="column-8">0.88</td><td
class="column-9">6.32</td><td
class="column-10">7.18</td></tr><tr
class="row-15 odd"><td
class="column-1">Scientific computing</td><td
class="column-2">hugetric-00010</td><td
class="column-3">6592765</td><td
class="column-4">9885854</td><td
class="column-5">3</td><td
class="column-6">3</td><td
class="column-7">2</td><td
class="column-8">1.07</td><td
class="column-9">8.1</td><td
class="column-10">7.56</td></tr><tr
class="row-16 even"><td
class="column-1">Scientific computing</td><td
class="column-2">hugetric-00020</td><td
class="column-3">7122792</td><td
class="column-4">10680777</td><td
class="column-5">3</td><td
class="column-6">3</td><td
class="column-7">2</td><td
class="column-8">1.19</td><td
class="column-9">9.03</td><td
class="column-10">7.6</td></tr><tr
class="row-17 odd"><td
class="column-1">Scientific computing</td><td
class="column-2">venturiLevel3</td><td
class="column-3">4026819</td><td
class="column-4">8054237</td><td
class="column-5">6</td><td
class="column-6">4</td><td
class="column-7">3</td><td
class="column-8">0.57</td><td
class="column-9">3.58</td><td
class="column-10">6.24</td></tr><tr
class="row-18 even"><td
class="column-1">Social</td><td
class="column-2">soc-friendster</td><td
class="column-3">65608366</td><td
class="column-4">1806067135</td><td
class="column-5">5214</td><td
class="column-6">55.06</td><td
class="column-7">129</td><td
class="column-8">1027.25</td><td
class="column-9">7680.92</td><td
class="column-10">7.48</td></tr><tr
class="row-19 odd"><td
class="column-1">Social</td><td
class="column-2">soc-livejournal07</td><td
class="column-3">5204176</td><td
class="column-4">48709773</td><td
class="column-5">15017</td><td
class="column-6">18.72</td><td
class="column-7">358</td><td
class="column-8">0.01</td><td
class="column-9">6.34</td><td
class="column-10">862.17</td></tr><tr
class="row-20 even"><td
class="column-1">Social</td><td
class="column-2">soc-livejournal-user-groups</td><td
class="column-3">7489073</td><td
class="column-4">112307315</td><td
class="column-5">1053749</td><td
class="column-6">29.99</td><td
class="column-7">9</td><td
class="column-8">717.73</td><td
class="column-9">36245</td><td
class="column-10">50.5</td></tr><tr
class="row-21 odd"><td
class="column-1">Social</td><td
class="column-2">soc-ljournal-2008</td><td
class="column-3">5363260</td><td
class="column-4">49514271</td><td
class="column-5">19432</td><td
class="column-6">18.46</td><td
class="column-7">400</td><td
class="column-8">0</td><td
class="column-9">7.22</td><td
class="column-10">7051.04</td></tr><tr
class="row-22 even"><td
class="column-1">Social</td><td
class="column-2">soc-orkut-dir</td><td
class="column-3">3072441</td><td
class="column-4">117185083</td><td
class="column-5">33313</td><td
class="column-6">76.28</td><td
class="column-7">51</td><td
class="column-8">55.78</td><td
class="column-9">228.94</td><td
class="column-10">4.1</td></tr><tr
class="row-23 odd"><td
class="column-1">Social</td><td
class="column-2">soc-sinaweibo</td><td
class="column-3">58655849</td><td
class="column-4">261321033</td><td
class="column-5">278489</td><td
class="column-6">8.91</td><td
class="column-7">44</td><td
class="column-8">94.84</td><td
class="column-9">2605</td><td
class="column-10">27.47</td></tr><tr
class="row-24 even"><td
class="column-1">Social (facebook)</td><td
class="column-2">socfb-A-anon</td><td
class="column-3">3097165</td><td
class="column-4">23667394</td><td
class="column-5">4915</td><td
class="column-6">15.28</td><td
class="column-7">25</td><td
class="column-8">9.01</td><td
class="column-9">21.75</td><td
class="column-10">2.41</td></tr><tr
class="row-25 odd"><td
class="column-1">Social (facebook)</td><td
class="column-2">socfb-konect.edges</td><td
class="column-3">46009640</td><td
class="column-4">72040814</td><td
class="column-5">4960</td><td
class="column-6">3.13</td><td
class="column-7">6</td><td
class="column-8">0.64</td><td
class="column-9">21.92</td><td
class="column-10">34.36</td></tr><tr
class="row-26 even"><td
class="column-1">Social (facebook)</td><td
class="column-2">socfb-uci-uni</td><td
class="column-3">58790782</td><td
class="column-4">92208195</td><td
class="column-5">4960</td><td
class="column-6">3.14</td><td
class="column-7">6</td><td
class="column-8">0.92</td><td
class="column-9">33.09</td><td
class="column-10">36.11</td></tr><tr
class="row-27 odd"><td
class="column-1">Web links</td><td
class="column-2">web-ClueWeb09-50m</td><td
class="column-3">428136612</td><td
class="column-4">446534058</td><td
class="column-5">308477</td><td
class="column-6">2.09</td><td
class="column-7">56</td><td
class="column-8">4.77</td><td
class="column-9">635.72</td><td
class="column-10">133.15</td></tr><tr
class="row-28 even"><td
class="column-1">Web links</td><td
class="column-2">web-indochina-2004-all</td><td
class="column-3">7414866</td><td
class="column-4">150984819</td><td
class="column-5">256425</td><td
class="column-6">40.72</td><td
class="column-7">6848</td><td
class="column-8">0.28</td><td
class="column-9">1137.24</td><td
class="column-10">4038.84</td></tr><tr
class="row-29 odd"><td
class="column-1">Web links</td><td
class="column-2">web-it-2004-all</td><td
class="column-3">41291318</td><td
class="column-4">1027474947</td><td
class="column-5">1326744</td><td
class="column-6">49.77</td><td
class="column-7">3222</td><td
class="column-8">0.19</td><td
class="column-9">162.32</td><td
class="column-10">832.67</td></tr><tr
class="row-30 even"><td
class="column-1">Web links</td><td
class="column-2">web-wikipedia_link_de</td><td
class="column-3">3930109</td><td
class="column-4">68714064</td><td
class="column-5">437732</td><td
class="column-6">34.97</td><td
class="column-7">339</td><td
class="column-8">0.01</td><td
class="column-9">10.33</td><td
class="column-10">1587.48</td></tr><tr
class="row-31 odd"><td
class="column-1">Web links</td><td
class="column-2">web-wikipedia_link_fr</td><td
class="column-3">5115915</td><td
class="column-4">104591689</td><td
class="column-5">1274642</td><td
class="column-6">40.89</td><td
class="column-7">332</td><td
class="column-8">0.12</td><td
class="column-9">23.8</td><td
class="column-10">206.31</td></tr></tbody></table><p>These and other algorithms have been tested over more than 275 real graphs. The full raw data together with a BBMCSP binary is available <a
title="Comparison of BBMCSP with PMC and others" href="http://venus.elai.upm.es/logs/results_sparse/" target="_blank">here</a>. <strong>We believe BBMCSP results  are clearly best on average for a stand-alone exact solver on massive graphs</strong>. If this is not the case, please let us know.</p><p>If we get a favorable feedback from readers interested in BBMCSP and/or in the maximum clique problem tailored  for very large or massive graphs we will explain the BBMCSP algorithm in full together with implementation details concerning BITSCAN and GRAPH.</p><p>Hope you enjoy this new BITSCAN and GRAPH application and, as always, we look forward to read what you think. Just click on the sidebar button to try biicode, check our<span
class="Apple-converted-space"> </span><a
href="http://docs.biicode.com/">docs</a>,<span
class="Apple-converted-space"> </span><a
href="http://forum.biicode.com/">forum</a><span
class="Apple-converted-space"> </span>and/or<span
class="Apple-converted-space"> </span><a
href="http://stackoverflow.com/questions/tagged/biicode?sort=newest">Stackoverflow tag</a><span
class="Apple-converted-space"> </span>for questions and answers or comment below to tell us your enquiries.</p><p>[1] Pardalos, P. Rebennack, S.; Experimental Algorithms. Lecture Notes in Computer Science, Volume 6049, 2010, pp 13-22.</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/maximum-clique-for-massive-sparse-graphs/">Maximum clique for massive sparse graphs</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></content:encoded> <wfw:commentRss>http://blog.biicode.com/maximum-clique-for-massive-sparse-graphs/feed/</wfw:commentRss> <slash:comments>2</slash:comments> </item> <item><title>Solving the maximum clique problem with BITSCAN</title><link>http://blog.biicode.com/maximum-clique-problem-bitscan-biicode/</link> <comments>http://blog.biicode.com/maximum-clique-problem-bitscan-biicode/#comments</comments> <pubDate>Fri, 30 Jan 2015 15:37:38 +0000</pubDate> <dc:creator><![CDATA[pablo]]></dc:creator> <category><![CDATA[algorithms]]></category> <category><![CDATA[biicode]]></category> <category><![CDATA[BITSCAN]]></category> <guid
isPermaLink="false">http://blog.biicode.com/?p=2049</guid> <description><![CDATA[<p>The maximum clique problem (MCP) consists in finding in a graph a clique—i.e., a complete subgraph, one such all vertices are pairwise adjacent— of maximum cardinality.  The term *clique* has its roots in the social sciences; in a social network, a clique refers to a group of individuals who all know—or are linked together by some relation such [&#8230;]</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/maximum-clique-problem-bitscan-biicode/">Solving the maximum clique problem with BITSCAN</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></description> <content:encoded><![CDATA[<p>The maximum clique problem (MCP) consists in finding in a graph a clique—i.e., a complete subgraph, one such all vertices are pairwise adjacent— of maximum cardinality.  The term *clique* has its roots in the social sciences; in a social network, a clique refers to a group of individuals who all know—or are linked together by some relation such as friendship— each other. The first algorithm for the MCP can be traced back to <a
title="Harary and Ross" href="http://www.jstor.org/discover/10.2307/2785673?sid=21105705789503&amp;uid=4&amp;uid=2&amp;uid=3737952" target="_blank">Harary &amp; Ross</a> in the late 50s. The first modern enumerative algorithm is most probably the one from <a
title="Bron &amp; Kerbosch" href="ftp://frcatel.fri.uniza.sk/pub/packages/math/doc/graphs/Bronkerb.pdf" target="_blank">Bron &amp; Kerbosch</a> in the early 70s.</p><div
id="attachment_2051" style="width: 310px" class="wp-caption aligncenter"><img
class="wp-image-2051 size-medium" src="http://blog.biicode.com/wp-content/uploads/sites/2/2015/01/temporalnetwork-300x293.png" alt="A retweet network can become a maximum clique problem solvable with BITSCAN" width="300" height="293" /><p
class="wp-caption-text">Figure 1. A retweet network</p></div><p>&nbsp;</p><p><span
id="more-2049"></span></p><h2>Maximum clique problem nowadays</h2><p>Since then, MCP has turned into one of the most studied NP-hard problems and is known to have many interesting applications in different fields, such as bioinformatics, coding theory, robotics, vision, network analysis etc. In addition to these it is also related to other important combinatorial optimization problems such as clique cover, vertex coloring or clique partitioning. Open Challenges of today include tailoring an efficient exact algorithm for massive sparse graphs, solving critical graphs from coding theory or solving correspondence graphs which appear when finding the optimal compatibility—i.e., matching— between two relational models.</p><p>One of the most efficient general purpose MCP solvers is BBMC, as pointed out by researcher Prosser in a recent <a
title="Maximum clique Survey" href="http://www.dcs.gla.ac.uk/~pat/maxClique/distribution/TR-2012-333.pdf" target="_blank">survey</a>. BBMC belongs to the family of efficient exact approximate coloring branch-and-bound algorithms. This class of algorithms combine exhaustive enumeration of cliques with the pruning of subproblems which fall below a certain bound obtained by a greedy sequential vertex coloring (SEQ). In a past <a
title="bit-parallel vertex coloring" href="http://blog.biicode.com/bit-parallel-approximate-coloring/" target="_blank">post </a>we showed an efficient implementation of SEQ.</p><h2>Maximum clique problem and BITSCAN</h2><p>BBMC is a bit-parallel algorithm and an efficient implementation based in BITSCAN and GRAPH libraries is available in the block <a
title="pablodev/copt" href="https://www.biicode.com/pablodev/copt" target="_blank">pablodev/copt</a> of the biicode repository. In this post we will not go into concrete implementation details, but instead report performance results of BBMC over a number of well known public instances from the <a
title="Clique benchmarks" href="http://dimacs.rutgers.edu/Challenges/" target="_blank">Second DIMACS Challenge</a>,  commonly used as test-bed. We hope these results will encourage readers to try BBMC and, hopefully, improve on it. The <a
title="pablodev/examples" href="https://www.biicode.com/pablodev/examples" target="_blank">pablodev/examples</a> block contains simple instructions on how to run BBMC—both in 64-bit Linux and Windows OS—.</p><p>Experiments were performed using a Linux workstation running a 64-bit Ubuntu release at 3.00GHz with an Intel(R) Xeon(R) CPU E5-2690 v2 multi-core processor and 128GB of main memory. The algorithm was run on a single core. In the table, ω is the cardinality of the maximum clique for each graph and ω_ini is an initial solution found by the algorithm during preprocessing.</p><table
id="tablepress-1" class="tablepress tablepress-id-1"><thead><tr
class="row-1 odd"><th
class="column-1">&nbsp;</th><th
class="column-2">name</th><th
class="column-3">ω</th><th
class="column-4">ω_ini</th><th
class="column-5">time(s)</th><th
class="column-6">&nbsp;</th><th
class="column-7">name</th><th
class="column-8">ω</th><th
class="column-9">ω_ini</th><th
class="column-10">time(s)</th><th
class="column-11">&nbsp;</th><th
class="column-12">&nbsp;</th></tr></thead><tbody
class="row-hover"><tr
class="row-2 even"><td
class="column-1"></td><td
class="column-2">brock200_1</td><td
class="column-3">21</td><td
class="column-4">17</td><td
class="column-5">0.213551</td><td
class="column-6"></td><td
class="column-7">san200_0.9_2</td><td
class="column-8">60</td><td
class="column-9">38</td><td
class="column-10">0.016267</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-3 odd"><td
class="column-1"></td><td
class="column-2">brock400_1</td><td
class="column-3">27</td><td
class="column-4">21</td><td
class="column-5">175.774196</td><td
class="column-6"></td><td
class="column-7">san200_0.9_3</td><td
class="column-8">44</td><td
class="column-9">30</td><td
class="column-10">0.017448</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-4 even"><td
class="column-1"></td><td
class="column-2">brock400_2</td><td
class="column-3">29</td><td
class="column-4">20</td><td
class="column-5">73.441771</td><td
class="column-6"></td><td
class="column-7">san400_0.7_1</td><td
class="column-8">40</td><td
class="column-9">20</td><td
class="column-10">0.110386</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-5 odd"><td
class="column-1"></td><td
class="column-2">brock400_3</td><td
class="column-3">31</td><td
class="column-4">21</td><td
class="column-5">123.074395</td><td
class="column-6"></td><td
class="column-7">san400_0.7_2</td><td
class="column-8">30</td><td
class="column-9">15</td><td
class="column-10">0.050643</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-6 even"><td
class="column-1"></td><td
class="column-2">brock400_4</td><td
class="column-3">33</td><td
class="column-4">20</td><td
class="column-5">59.980232</td><td
class="column-6"></td><td
class="column-7">san400_0.7_3</td><td
class="column-8">22</td><td
class="column-9">13</td><td
class="column-10">0.276578</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-7 odd"><td
class="column-1"></td><td
class="column-2">hamming10-2</td><td
class="column-3">512</td><td
class="column-4">512</td><td
class="column-5">0.010701</td><td
class="column-6"></td><td
class="column-7">san400_0.9_1</td><td
class="column-8">100</td><td
class="column-9">49</td><td
class="column-10">0.080698</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-8 even"><td
class="column-1"></td><td
class="column-2">hamming8-4</td><td
class="column-3">16</td><td
class="column-4">16</td><td
class="column-5">0.012516</td><td
class="column-6"></td><td
class="column-7">san1000</td><td
class="column-8">15</td><td
class="column-9">8</td><td
class="column-10">0.543332</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-9 odd"><td
class="column-1"></td><td
class="column-2">johnson16-2-4</td><td
class="column-3">8</td><td
class="column-4">8</td><td
class="column-5">0.045864</td><td
class="column-6"></td><td
class="column-7">sanr200_0.7</td><td
class="column-8">18</td><td
class="column-9">14</td><td
class="column-10">0.07264</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-10 even"><td
class="column-1"></td><td
class="column-2">johnson8-4-4</td><td
class="column-3">14</td><td
class="column-4">14</td><td
class="column-5">&gt;0.001</td><td
class="column-6"></td><td
class="column-7">sanr200_0.9</td><td
class="column-8">42</td><td
class="column-9">35</td><td
class="column-10">9.46994</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-11 odd"><td
class="column-1"></td><td
class="column-2">keller4</td><td
class="column-3">11</td><td
class="column-4">9</td><td
class="column-5">0.007029</td><td
class="column-6"></td><td
class="column-7">sanr400_0.5</td><td
class="column-8">13</td><td
class="column-9">12</td><td
class="column-10">0.148937</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-12 even"><td
class="column-1"></td><td
class="column-2">phat300-3</td><td
class="column-3">36</td><td
class="column-4">33</td><td
class="column-5">0.636308</td><td
class="column-6"></td><td
class="column-7">sanr400_0.7</td><td
class="column-8">21</td><td
class="column-9">17</td><td
class="column-10">44.314098</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-13 odd"><td
class="column-1"></td><td
class="column-2">phat500-2</td><td
class="column-3">36</td><td
class="column-4">33</td><td
class="column-5">0.135654</td><td
class="column-6"></td><td
class="column-7">gen200_p0.9_44</td><td
class="column-8">44</td><td
class="column-9">31</td><td
class="column-10">0.160373</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-14 even"><td
class="column-1"></td><td
class="column-2">phat500-3</td><td
class="column-3">50</td><td
class="column-4">44</td><td
class="column-5">35.310753</td><td
class="column-6"></td><td
class="column-7">gen200_p0.9_55</td><td
class="column-8">55</td><td
class="column-9">37</td><td
class="column-10">0.171129</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-15 odd"><td
class="column-1"></td><td
class="column-2">phat700-2</td><td
class="column-3">44</td><td
class="column-4">41</td><td
class="column-5">1.316244</td><td
class="column-6"></td><td
class="column-7">C125.9</td><td
class="column-8">34</td><td
class="column-9">32</td><td
class="column-10">0.016274</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-16 even"><td
class="column-1"></td><td
class="column-2">phat1000-1</td><td
class="column-3">10</td><td
class="column-4">9</td><td
class="column-5">0.131477</td><td
class="column-6"></td><td
class="column-7">Mann_a27</td><td
class="column-8">126</td><td
class="column-9">125</td><td
class="column-10">0.014025</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-17 odd"><td
class="column-1"></td><td
class="column-2">phat1000-2</td><td
class="column-3">46</td><td
class="column-4">40</td><td
class="column-5">63.452562</td><td
class="column-6"></td><td
class="column-7">Mann_a45</td><td
class="column-8">345</td><td
class="column-9">341</td><td
class="column-10">55.404925</td><td
class="column-11"></td><td
class="column-12"></td></tr><tr
class="row-18 even"><td
class="column-1"></td><td
class="column-2">phat1500-1</td><td
class="column-3">12</td><td
class="column-4">11</td><td
class="column-5">1.224909</td><td
class="column-6"></td><td
class="column-7">dsjc500.5</td><td
class="column-8">13</td><td
class="column-9">11</td><td
class="column-10">0.763129</td><td
class="column-11"></td><td
class="column-12"></td></tr></tbody></table><p
class="biblio"><span
lang="EN-US">If we get a favourable feedback from readers interested in BBMC and in the maximum clique problem we will start a weekly section on the topic. </span></p><p>&nbsp;</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/maximum-clique-problem-bitscan-biicode/">Solving the maximum clique problem with BITSCAN</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></content:encoded> <wfw:commentRss>http://blog.biicode.com/maximum-clique-problem-bitscan-biicode/feed/</wfw:commentRss> <slash:comments>0</slash:comments> </item> <item><title>Bit-parallel approximate coloring</title><link>http://blog.biicode.com/bit-parallel-approximate-coloring/</link> <comments>http://blog.biicode.com/bit-parallel-approximate-coloring/#comments</comments> <pubDate>Wed, 26 Nov 2014 14:34:26 +0000</pubDate> <dc:creator><![CDATA[pablo]]></dc:creator> <category><![CDATA[BITSCAN]]></category> <category><![CDATA[bit parallelism]]></category> <category><![CDATA[bit-parallel transmission]]></category> <category><![CDATA[bitscan]]></category> <category><![CDATA[c++]]></category> <category><![CDATA[Maximum Cliqué Problem]]></category> <category><![CDATA[SEQ]]></category> <category><![CDATA[sequential greedy coloring]]></category> <guid
isPermaLink="false">http://blog.biicode.com/?p=1914</guid> <description><![CDATA[<p>The vertex coloring problem (VCP) is an NP-hard classical problem in graph theory which can be traced back to a letter written to W.R. Hamilton by A. de Morgan in 1852 in which the famous Four Color Theorem has its roots. Besides its obvious theoretical relevance, it has found practical applications connected to scheduling and [&#8230;]</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/bit-parallel-approximate-coloring/">Bit-parallel approximate coloring</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></description> <content:encoded><![CDATA[<p>The vertex coloring problem (VCP) is an NP-hard classical problem in graph theory which can be traced back to a letter written to W.R. Hamilton by A. de Morgan in 1852 in which the famous <em>Four Color Theorem</em> has its roots. Besides its obvious theoretical relevance, it has found practical applications connected to scheduling and allocation of resources (i.e. memory for different processes, frequencies for WLANs etc.).<br
/> A (proper) vertex coloring of a simple undirected graph G=(V, E) is an assignment of color numbers to all vertices such that pairwise adjacent vertices have different colors. The size of the coloring is the number of different colors employed. The chromatic number of a graph χ(G) is the minimum number of colors required to color G, i.e. the size of its optimum coloring. The VCP can be formulated as finding a minimum coloring for a given graph.<br
/> Compared with other related graph optimization problems such as the maximum clique problem (i.e. finding the largest possible subgraph in a given graph), VCP is considerably more challenging; for example it is possible to compute a maximum clique exactly in massive sparse graphs with millions of vertices, whereas fast exact coloring of a random graph with 80 vertices and 0.5 edge density already requires efficient algorithms and a powerful CPU.</p><p><span
id="more-1914"></span></p><h2>Sequential greedy approximate coloring (SEQ)</h2><p>This post is concerned with a specific approximate coloring procedure called sequential greedy coloring (usually referred to as SEQ). It is a very useful and simple heuristic which produces reasonably tight colorings. A typical implementation runs in O(|V|* |V|) although procedures in O(|E|) are also known and employed in large sparse graphs.<br
/> SEQ assigns the smallest possible color number to each vertex in order consistent with the current partial coloring. Pseudocode for SEQ appears in listing 1.</p><pre class="crayon-plain-tag">SEQ (G(V={v1, v2, …, vn} , E))
1. for v≔v1 to vn
2.   assign the smallest possible color to v
3. endfor</pre><p><strong>Listing 1</strong>. Sequential greedy coloring.</p><p
align="justify"><span
lang="en-US"><b>Figure 1</b></span><span
lang="en-US"> below shows an example of a coloring produced by SEQ. The numbers inside the vertices indicate the predefined ordering. In the example SEQ starts by labelling vertex 1 with color number 1 (green) and then proceeds to label vertex 2 with color number 2 (yellow) because it is adjacent to 1. Thereafter the smallest possible color for vertex 3 is green, vertex 4 is colored yellow and finally vertex 5 requires an additional color number (cyan) because it is adjacent to 1 and 4.</span></p><p>&nbsp;</p><table
width="100%" cellspacing="0" cellpadding="7"><tbody><tr><td
width="51%"><img
class="aligncenter wp-image-1915 size-full" src="http://blog.biicode.com/wp-content/uploads/sites/2/2014/11/greedy-coloring1.png" alt="Examples of SEQ " width="341" height="299" /></td><td
width="49%"><img
class="aligncenter wp-image-1916 size-full" src="http://blog.biicode.com/wp-content/uploads/sites/2/2014/11/greedy-coloring2.png" alt="Example 2 of SEQ" width="342" height="300" /></td></tr><tr><td
colspan="2" valign="top" width="100%"><b>Figure 1</b>. An example of sequential greedy coloring (in this case also a minimum coloring and solution to the VCP)</td></tr></tbody></table><p
style="text-align: left;"> <span
lang="en-US">The resulting coloring C(G)={C</span><sub><span
lang="en-US">1</span></sub><span
lang="en-US">, C</span><sub><span
lang="en-US">2</span></sub><span
lang="en-US">, C</span><sub><span
lang="en-US">3</span></sub><span
lang="en-US">} has size three with color sets C</span><sub><span
lang="en-US">1</span></sub><span
lang="en-US">={1, 3}, C</span><sub><span
lang="en-US">2</span></sub><span
lang="en-US">={2, 4} and C</span><sub><span
lang="en-US">3</span></sub><span
lang="en-US">={5}. Note that each color set is an </span><span
lang="en-US"><i>independent set</i></span><span
lang="en-US">, i.e. all its members are pairwise non-adjacent. This is a common property of all vertex colorings.</span></p><h2>An efficient bit-parallel implementation of SEQ</h2><p>We will now show a very efficient way of implementing SEQ in a bit-encoded graph to exploit bit-parallel transmission. We assume the reader has a minimum knowledge of both  <a
title="GRAPH block in Biicode repository" href="https://www.biicode.com/pablodev/graph">GRAPH</a> and <a
title="BITSCAN block in Biicode repository" href="https://www.biicode.com/pablodev/bitscan">BITSCAN</a> C++ libraries. If this is not the case we refer the reader to the documentation in the corresponding blocks in the Biicode repository.</p><p
align="justify"><span
lang="en-US">The bit-encoded graph encoded by GRAPH contains |V| bitarrays which map the neighbor sets of every vertex (i.e. each row of the adjacency matrix). In the example of </span><span
lang="en-US"><b>figure 1</b></span><span
lang="en-US"> the graph is encoded with the following 5 bitstrings: B{1} = 01011, B{2}=10101, B{3}=01011, B{4}=10101 and B{5}=11110. In a similar fashion, vertex sets and induced subgraphs are mapped to bitstrings when needed making use of BITSCAN.</span></p><p
align="justify"><span
lang="en-US">When exploiting bit-parallelism it is important that algorithms are carefully designed so that the critical operations are computed through bitmasks. Typical </span><span
lang="en-US"><i>good</i></span><span
lang="en-US"> operations when working with bit-encoded sets are </span><span
lang="en-US"><i>set-intersection</i></span><span
lang="en-US"> and </span><span
lang="en-US"><i>set-difference</i></span><span
lang="en-US">. A </span><span
lang="en-US"><i>bad</i></span><span
lang="en-US"> operation frequently needed is </span><span
lang="en-US"><i>set element enumeration</i></span><span
lang="en-US"> (i.e. determining the position of all 1-bits in the bitarray). </span></p><p
align="justify"><span
lang="en-US">In the case of SEQ a good compromise between </span><span
lang="en-US"><i>good</i></span><span
lang="en-US"> and </span><span
lang="en-US"><i>bad</i></span><span
lang="en-US"> operations is achieved by changing the control flow </span><span
lang="en-US"><i>to produce color sets sequentially </i></span><span
lang="en-US">(in the example first C</span><sub><span
lang="en-US">1</span></sub><span
lang="en-US"> then C</span><sub><span
lang="en-US">2</span></sub><span
lang="en-US"> and finally C</span><sub><span
lang="en-US">3</span></sub><span
lang="en-US">). Note that now no vertex is assigned color number </span><span
lang="en-US"><i>k</i></span><span
lang="en-US"> until all color sets below </span><span
lang="en-US"><i>k</i></span><span
lang="en-US"> have been completed. </span><span
lang="en-US"><b>Listing 2</b></span><span
lang="en-US"> describes the proposed modification for the SEQ algorithm.</span></p><p></p><pre class="crayon-plain-tag">BIT_PARALLEL_SEQ (G)
Initial step: U≔V, k:=1, C:= EMPTY
Output: A greedy sequential class coloring C(G)
1. while U is not empty
2.    Ck≔U                                                              //candidate set to color
3.    repeat until all vertices in Ck have been selected
4.      choose the first vertex v from Ck not previously selected
5.      remove from Ck vertices not adjacent to v                       //main coloring operation
6.      remove v from U                                                 //mark v as colored
7.    endrepeat                                                         //end of color Ck
8. add Ck to the output coloring C
9. k≔k+1                                                                //next color set
10.endwhile</pre><p><strong>Listing 2.</strong> BIT_PARALLEL_SEQ. It computes color classes sequentially.</p><p
align="justify"><span
lang="en-US"><b>Listing 3</b></span><span
lang="en-US"> describes an efficient implementation of BIT_PARALLEL_SEQ with GRAPH. The procedure receives as input the graph to be colored (encoded as the</span><span
lang="en-US"><i> ugraph</i></span><span
lang="en-US"> type from GRAPH) and returns the size of the coloring and the concrete color assignments (in vector </span><span
lang="en-US"><i>color</i></span><span
lang="en-US"> passed as parameter). The procedure uses two auxiliary vertex sets </span><span
lang="en-US"><i>m_unsel</i></span><span
lang="en-US"> and </span><span
lang="en-US"><i>m_sel</i></span><span
lang="en-US"> bit-encoded with BITSCAN. </span><span
lang="en-US"><i>m_unsel</i></span> <i> </i><span
lang="en-US">refers to the</span><i> </i><span
lang="en-US">remaining uncolored vertices; </span><span
lang="en-US"><i>m_sel</i></span><span
lang="en-US"> contains the candidate vertices which can enlarge the current color class. Initially </span><span
lang="en-US"><i>m_unsel</i></span><span
lang="en-US"> is mapped to V (i.e. all bits are set to one).</span></p><p></p><pre class="crayon-plain-tag">#include "pablodev/graph/graph.h"		//header for GRAPH in Biicode repository
int BIT_PARALLEL_SEQ (ugraph&amp; G, vector&lt;int&gt;&amp; color){
  //initial values
  int N=G.number_of_vertices(), k=0, v= EMPTY_ELEM, from=EMPTY_ELEM;
  color.assign(N, EMPTY_ELEM);
  m_unsel.set_bit(0, N-1);                       //initially maps to V: all bits to 1
  //main loop
  while(true){
    m_sel=m_unsel;
    m_sel.init_scan(bbo::DESTRUCTIVE);
    while(true){
       if((v=m_sel.next_bit_del(from, m_unsel))==EMPTY_ELEM) break;
       color[v]=k;                                //stores the vertex color number
       if((--N)==0)
               return k;                          //exit point
       //computes next vertex of the current color class
       m_sel.erase_block(from, G.get_neighbors(v));
    }
    ++k;                                          //next color
  }
  return k;                                       //should not reach here
}</pre><p><strong>Listing 3.</strong> The proposed BIT_PARALLEL_SEQ implementation.</p><p
align="justify"><span
lang="en-US">The procedure is made up of two nested loops. The outer loop sets the candidate vertices of a new color set C</span><sub><span
lang="en-US">k</span></sub><span
lang="en-US"> in</span><span
lang="en-US"><i> m_sel</i></span><span
lang="en-US">, while the inner loop computes C</span><sub><span
lang="en-US">k</span></sub><span
lang="en-US">. Critical operations that make use of bit-parallel transmission are:</span></p><ol><li><p
align="justify"><span
lang="en-US">Copy of uncolored vertices from </span><span
lang="en-US"><i>m_unsel</i></span><span
lang="en-US"> to </span><span
lang="en-US"><i>m_sel</i></span><span
lang="en-US"> at the beginning of the outer loop.</span></p></li><li><p
align="justify"><span
lang="en-US">Filtering of candidate vertices for the current color set by the BITSCAN </span><span
lang="en-US"><i>erase_block</i></span><span
lang="en-US"> function (computed as a set_difference operation).</span></p></li></ol><p
align="justify"><span
lang="en-US">Enumeration of vertices in </span><span
lang="en-US"><i>m_sel</i></span><span
lang="en-US"> is one of the </span><span
lang="en-US"><i>bad </i></span><span
lang="en-US">operations but is implemented as an efficient </span><span
lang="en-US"><i>destructive BITSCAN loop</i></span><span
lang="en-US"> (see BITSCAN reference) in the inner loop of BIT_PARALLEL_SEQ:</span></p><p></p><pre class="crayon-plain-tag">m_sel.init_scan(bbo::DESTRUCTIVE);
while(true){
  if((v=m_sel.next_bit_del(from, m_unsel))==EMPTY_ELEM) break;
  //…
}</pre><p></p><p
align="justify"><span
lang="en-US">Inside the inner loop, each time a vertex </span><span
lang="en-US"><i>v </i></span><span
lang="en-US">is selected it is deleted simultaneously from </span><span
lang="en-US"><i>m_sel</i></span><span
lang="en-US"> and </span><span
lang="en-US"><i>m_unsel </i></span><span
lang="en-US">in </span><span
lang="en-US"><i>next_bit_del</i></span><span
lang="en-US"> which is a useful optimization. Afterwards </span><span
lang="en-US"><i>color </i></span><span
lang="en-US">is updated with the new label for </span><span
lang="en-US"><i>v </i></span><span
lang="en-US">(color[v]=k) and the empty set condition is evaluated (&#8211;N==0) to check if all vertices are colored. If this is not the case the procedure enters into the </span><span
lang="en-US"><i>erase_block</i></span><span
lang="en-US"> coloring operation which removes those vertices which cannot now make part of the current color class and proceeds with the next iteration. Noteworthy is that </span><span
lang="en-US"><i>erase_block </i></span><span
lang="en-US">has been optimized in BITSCAN so that only blocks in </span><span
lang="en-US"><i>m_sel</i></span><span
lang="en-US"> containing the current vertex </span><span
lang="en-US"><i>v</i></span><span
lang="en-US"> (index block </span><span
lang="en-US"><i>from</i></span><span
lang="en-US">) and higher are considered in the filter.</span></p><p
align="justify"><span
lang="en-US">We hope readers enjoy BIT_PARALLEL_SEQ. It is extremely fast and is currently being used as part of <em>state-of-the-art</em> maximum clique algorithm <a
title="Reference to BBMC algorithm" href="http://dl.acm.org/citation.cfm?id=1860369">BBMC</a> in to compute clique upper bounds. The implementation described here is available in the combinatorial optimization block <a
title="Combinatorial block in Biicode repository" href="https://www.biicode.com/pablodev/copt">pablodev/copt </a> in the Biicode repository.</span></p><p>If you liked this post please comment below. If you want to try biicode just click on the sidebar button and if you have any doubts check our <a
href="http://docs.biicode.com">docs</a>, <a
href="http://forum.biicode.com">forum</a>, <a
href="http://stackoverflow.com/questions/tagged/biicode?sort=newest">Stackoverflow tag</a> and <a
href="https://github.com/biicode">Github repos</a>.</p><p><a
href="http://www.codeproject.com/script/Articles/BlogFeedList.aspx?amid=<11052799>&#8221; rel=&#8221;tag&#8221;>CodeProject style=&#8221;display:none&#8221;</a></p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/bit-parallel-approximate-coloring/">Bit-parallel approximate coloring</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></content:encoded> <wfw:commentRss>http://blog.biicode.com/bit-parallel-approximate-coloring/feed/</wfw:commentRss> <slash:comments>1</slash:comments> </item> <item><title>BITSCAN: a C++ library for bit strings</title><link>http://blog.biicode.com/bitscan-cpp-library-bit-strings/</link> <comments>http://blog.biicode.com/bitscan-cpp-library-bit-strings/#comments</comments> <pubDate>Fri, 17 Oct 2014 11:03:03 +0000</pubDate> <dc:creator><![CDATA[pablo]]></dc:creator> <category><![CDATA[BITSCAN]]></category> <category><![CDATA[bit string]]></category> <category><![CDATA[bitscan]]></category> <category><![CDATA[bitscanning]]></category> <category><![CDATA[c++]]></category> <category><![CDATA[cpp]]></category> <guid
isPermaLink="false">http://blog.biicode.com/?p=1840</guid> <description><![CDATA[<p>A comprehensive view of BITSCAN BITSCAN is a C++ library dedicated to efficient processing of bit strings. In programming, a bit string is a data structure that stores collections of bits (ones and zeros). It gets interesting when these bits have semantics, i.e.  refer to a Boolean property of a group, so that each element is [&#8230;]</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/bitscan-cpp-library-bit-strings/">BITSCAN: a C++ library for bit strings</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></description> <content:encoded><![CDATA[<h2>A comprehensive view of BITSCAN</h2><p>BITSCAN is a C++ library dedicated to efficient processing of bit strings. In programming, a bit string is a data structure that stores collections of bits (ones and zeros). It gets interesting when these bits have semantics, i.e.  refer to a Boolean property of a group, so that each element is identified by a bit in the chain. In previous posts I have repeatedly stated that BITSCAN “is a useful library to manage bit strings”, and that was that. Readers of our blog have questioned the usefulness of bit strings in practice so I will start this post explaining some common situations in which bit strings may be an alternative to more common data structures.</p><p><img
class="aligncenter wp-image-1841 size-full" src="http://blog.biicode.com/wp-content/uploads/sites/2/2014/10/bitstring_logo.png" alt="Bit strings can now be processed more powerfully with BITSCAN hosted in biicode" width="359" height="123" /></p><p><span
id="more-1840"></span></p><h2>Bit strings in practice</h2><p>Say you need to store and compare subsets of <em>different</em> numbers from 1 to N; or possibly you need to encode that a collection of objects belong to a set, or perhaps reason with two such collections and find those common to both. These situations are quite frequent in practice and commonly solved by mapping objects to identifiers, storing them (typically in some predefined order) in containers and employ their built-in methods to make the required inferences.</p><p>Here is an example: a subset of students takes an exam; each student has a different ID and writes it on the exam. A possible (non-efficient) solution to the query as to which students did not assist using STL collections appears below:</p><pre class="crayon-plain-tag">//… appropiate headers
template&lt;class Collection&gt;
void printCol(Collection&amp; col){
	copy(col.begin(), col.end(), ostream_iterator&lt;Collection::value_type&gt;(cout, " "));
}
#define NUMBER_OF_STUDENTS 5
void main(){
	set&lt;int&gt; s_ids;		// student ids
	set&lt;int&gt; e_ids;		// exam ids
	for(int i=1; i&lt;=NUMBER_OF_STUDENTS; i++){
		s_ids.insert(i);
		if((i%2)==0)
			e_ids.insert(i);
	}
	//students which did not assist
	set&lt;int&gt; s_not_assist;
  	set_difference(s_ids.begin(), s_ids.end(), e_ids.begin(), e_ids.end(),
                             insert_iterator&lt;set&lt;int&gt;&gt; (s_not_assist, s_not_assist.begin()) );
	printCol(s_not_assist);
}</pre><p>&nbsp;</p><p>In the PREVIOUS example  each call to <code>insert</code> is logarithmic and <code>set_difference</code> is linear in the number of total students. Now compare with a bit string encoding for exams and students (a 1-bit indicates membership):</p><pre class="crayon-plain-tag">#include "pablodev/bitscan/bitscan.h"		//BITSCAN header in biicode repository
using namespace std;
#define NUMBER_OF_STUDENTS 5
void main(){
	bitarray s_ids(NUMBER_OF_STUDENTS);	// student ids
	bitarray e_ids(NUMBER_OF_STUDENTS);	// exam ids
	s_ids.set_bit(0,NUMBER_OF_STUDENTS-1);
	for(int i=1; i&lt;=NUMBER_OF_STUDENTS; i++){
		if((i%2)==0)
		e_ids.set_bit(i-1);		//id is 0 based
	}
	//students which passed the exam
	bitarray s_not_assist(s_ids);
	s_not_assist.erase_bit(e_ids);
	//I/O
	s_not_assist.print();
}</pre><p>From the point of view of efficiency, students are inserted in the (bit) sets in constant time. The reasoning is computed in the <code>erase_bit</code> function in linear time, but there is a reduction by a constant factor related to register word size (typically 64 in today’s computers) because processing occurs in chunks of bit blocks. Moreover, the code is no less readable (possibly <em>more</em> readable) than its counterpart and slightly more compact.</p><p>Note that the example did not intend to suggest that bit strings are better than typical STL collections (exlcude std::bitset) or anything like that. It only shows that bit strings can be a useful alternative to consider in everyday programming.</p><h2>Data types available in BITSCAN</h2><p>Having made a case in favor of bit strings I will now comment briefly on the data types available in BITSCAN and the kind of problems they address. As stated in <a
href="http://blog.biicode.com/category/bitscan-2/">previous posts</a>, I developed BITSCAN to deal with hard combinatorial optimization problems in the graph domain. Why did I not use other common solutions such as <code>std</code><code>∷</code><code>bitset</code> or boost<code>∷</code><code>dynamic_bitset</code> containers? Simply because the majority of functions I required back then (say almost a decade ago) were not built-in (they still aren&#8217;t, specifically those related to different types of efficient bit scanning) not to mention the fact that the size of <code>std</code><code>∷</code><code>bitset</code> has to be hard wired at compile time. Also some critical optimization issues appeared which required ad hoc solutions. I therefore decided to start from scratch at my own risk. The types in BITSCAN are a result of a decade of experience in algorithmic optimization. The current release is intended to share this knowledge in the hope that it is useful to others and that it may be improved. In this sense I find Biicode ideal for managing and sharing the code.</p><p>Back to business, and sorry for the digression. The main types in BITSCAN are <em>bitblock</em>, <em>bitarray</em> and <em>sparse_bitarray</em> and most of the time you will only be using these. Other types are meant for compilers which do not accept assembly or intrinsic instructions (i.e. <em>simple_bitarray</em>, <em>simple_sparse_array</em>) or some specific optimization (i.e. <em>watched_bitarray</em>). I will leave the latter types for a future post.</p><h3>TYPE bitblock</h3><p>The <em>bitblock</em> type is a wrapper for bit twiddling inside 64 bit numbers. It includes typical least- significant-bit (LSB) and most-significant-bit (MSB) functions as well as different implementations of population counts (i.e. number of 1-bits in the number).  Useful inline macros are MASK_1 and MASK_0 which change bits in a predefined range (see example below).</p><pre class="crayon-plain-tag">#include &lt;iostream&gt;
#include "pablodev/bitscan/bitscan.h"
using namespace std;
void main(){
	BITBOARD bb=0xFFFF;
	cout&lt;&lt;"number of 1-bits in bb:"&lt;&lt;bitblock::popc64(bb)&lt;&lt;endl;
	//useful masks
	bitblock::print(bb &amp; bitblock::MASK_0(4,8));    //removes bits 4-8 from bb
	bitblock::print(bb | bitblock::MASK_1(4,8));    //sets bits 4-8 in bb
}</pre><p></p><h3>TYPE bitarray</h3><p><em>bitarray</em> extends the <em>bitblock</em> type to arrays of bitblocks and it is BITSCAN&#8217;s basic type. Besides typical operations which may be found elsewhere (bit masks etc.), the wrapper contains a number of optimizations mainly concerned with extracting the information from bit strings (alias bitscanning) which I have found pretty useful when solving combinatorial problems. In particular:</p><ul><li>Caching bitblock index and position of the last bit scanned in a bit scanning loop.</li><li>Specific implementation for destructive (simultaneous scanning and deletion) scans.</li><li>Specific implementation for reverse scans (i.e. from last to least significant bit of the bitstring).</li></ul><p>Here is a simple example of how to implement normal and destructive scanning loops with BITSCAN:</p><pre class="crayon-plain-tag">#include &lt;iostream&gt;
#include "pablodev/bitscan/bitscan.h"
using namespace std;
#define POPULATION_SIZE 100
void main(){
	bitarray bba(POPULATION_SIZE);
	bba.set_bit(0, POPULATON_SIZE-1);     //sets all bits to 1
	//bit scanning loop
	int nBit=EMPTY_ELEM;
	bba.init_scan(bbo::NON_DESTRUCTIVE);
	while(true){
		nBit=bba.next_bit();
		if(nBit==EMPTY_ELEM) break;
		cout&lt;&lt;nBit&lt;&lt;" ";
	}
	cout&lt;&lt;endl;
	//bit scanning loop (destructive)
	nBit=EMPTY_ELEM;
	bba.init_scan(bbo::DESTRUCTIVE);
	while(true){
		nBit=bba.next_bit_del();
		if(nBit==EMPTY_ELEM) break;
		cout&lt;&lt;nBit&lt;&lt;" ";
	}
}</pre><p><span
style="font-size: 13px;">It is worth noting that bit scanning introduces critical overhead compared to standard data structures. I strongly recommend to avoid it as much as possible in critical problem solving routines  in favor of reasoning with bit masks (the good part). Still, at some point you will surely need to enumerate the elements (1-bits) in the bit sets and the above functions (and others available in BITSCAN) will come in handy.</span></p><h3>TYPE sparse_bitarray</h3><p>This type introduces specific functionality to deal with the sparse case. A sparse bit string typically holds many more 0-bits than 1-bits (usually the useful chunks of information) and using  the general purpose <em>bitarray</em> type will generally lead to dealing with a lot of useless chunks of 0-bits. I recommend to use the <em>sparse_bitarray</em> type in such cases. The interface for most operations is very much the same. BELOW is the code for the normal bit scanning loop in the previous examples but using the sparse type.</p><pre class="crayon-plain-tag">#include &lt;iostream&gt;
#include "pablodev/bitscan/bitscan.h"
using namespace std;
#define POPULATION_SIZE 100
void main(){
	sparse_bitarray bba(POPULATION_SIZE);
	bba.set_bit(0, POPULATION_SIZE-1);      //sets all bits to 1
	//bit scanning loop
	int nBit=EMPTY_ELEM;
	if(bba.init_scan(bbo::NON_DESTRUCTIVE)!=EMPTY_ELEM){
		while(true){
			nBit=bba.next_bit();
			if(nBit==EMPTY_ELEM) break;
			cout&lt;&lt;nBit&lt;&lt;" ";
		}
	}
	cout&lt;&lt;endl;
}</pre><p>Notice that the code is exactly the same as for the <em>bitarray</em> type (now <em>sparse_bitarray</em>) with the exception of the empty checking condition at the beginning of the bit scanning loop:</p><pre class="crayon-plain-tag">if(bba.init_scan(bbo::NON_DESTRUCTIVE)!=EMPTY_ELEM)(…}</pre><p>This is necessary because sparse bitarrays have empty semantics: an empty bitarray (i.e. with no allocated bitblocks) might just as well not be used as refer to a bitset exent of 1-bits. Either way entering the main scanning loop will result in an error during execution.</p><h2>Current status</h2><p>As indicated in other posts, BITSCAN is still very much in Alpha but it is being actively developed.  As such it suffers from lack of proper doc, non standardization of names and namespaces etc.  Still, it is very simple to use and including it in your projects requires no effort using Biicode (just include the header  #include &#8220;pablodev/bitscan/bitscan.h&#8221; and you are done). It has been tested both in Linux and Windows (64 bit).</p><p>If you are wondering about efficiency,  BITSCAN is in the core of BBMC <sup><a
href="#fn1" id="ref1">[1]</a></sup><sup><a
href="#fn2" id="ref2">[2]</a></sup><sup><a
href="#fn3" id="ref3">[3]</a></sup> and PASS <sup><a
href="#fn4" id="ref4">[4]</a></sup>, two state of the art algorithms for the NP-hard maximum clique and vertex coloring problems respectively. Also worth reading is a performance comparison with STL and BOOST in <sup><a
href="#fn5" id="ref5">[5]</a></sup>. If you finally decide that it is worth a try please read the legal stuff. In case you use it for research purposes, please include the indicated citations. Finally, any feedback or improvement is most welcome.</p><p>&nbsp;</p><p><sup
id="fn1"><a
href="http://dl.acm.org/citation.cfm?id=1860369%20">[1] An exact bit-parallel algorithm for the maximum clique problem</a></sup></p><p><sup
id="fn2"><a
href="http://link.springer.com/article/10.1007%2Fs11590-011-0431-y">[2] An improved bit parallel exact maximum clique algorithm</a></sup></p><p><sup
id="fn3"><a
href="http://dl.acm.org/citation.cfm?id=2566230">[3] Relaxed approximate coloring in exact maximum clique search</a></sup></p><p><sup
id="fn4"><a
href="/oa.upm.es/11802/2/INVE_MEM_2011_107285.pdf">[4] A new DSATUR-based algorithm for exact vértex coloring</a></sup></p><p><sup
id="fn5"><a
href="http://blog.biicode.com/bitscan-efficiency-at-glance/">[5] BITSCAN efficiency at a glance</a></sup></p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/bitscan-cpp-library-bit-strings/">BITSCAN: a C++ library for bit strings</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></content:encoded> <wfw:commentRss>http://blog.biicode.com/bitscan-cpp-library-bit-strings/feed/</wfw:commentRss> <slash:comments>0</slash:comments> </item> <item><title>Sparse bitsets in C++ with BITSCAN</title><link>http://blog.biicode.com/sparse-bitsets-cpp/</link> <comments>http://blog.biicode.com/sparse-bitsets-cpp/#comments</comments> <pubDate>Tue, 23 Sep 2014 09:01:20 +0000</pubDate> <dc:creator><![CDATA[pablo]]></dc:creator> <category><![CDATA[BITSCAN]]></category> <category><![CDATA[bitscan]]></category> <category><![CDATA[bitstring analysis]]></category> <category><![CDATA[c++]]></category> <category><![CDATA[cpp]]></category> <category><![CDATA[graph]]></category> <category><![CDATA[sparse]]></category> <category><![CDATA[sparse bitsets]]></category> <category><![CDATA[sparsity]]></category> <category><![CDATA[ugraph]]></category> <guid
isPermaLink="false">http://blog.biicode.com/?p=1584</guid> <description><![CDATA[<p>Sparse bitsets in C++ Sparsity when referring to systems indicates that they are loosely coupled. Thus, a sparse matrix is a matrix in which most of its elements are zero, a sparse graph has very few adjacent vertices (its adjacency matrix is also sparse) etc. Opposite to sparsity is density, and dense systems are those [&#8230;]</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/sparse-bitsets-cpp/">Sparse bitsets in C++ with BITSCAN</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></description> <content:encoded><![CDATA[<h2>Sparse bitsets in C++</h2><p><em>Sparsity</em> when referring to systems indicates that they are loosely coupled. Thus, a sparse matrix is a matrix in which most of its elements are zero, a sparse graph has very few adjacent vertices (its adjacency matrix is also sparse) etc. Opposite to sparsity is density, and dense systems are those that are strongly coupled.</p><p>In a recent post we proposed <a
title="K CORES analysis bitscan" href="http://blog.biicode.com/k-cores-analysis-bitscan/" target="_blank">BITSCAN </a> a recent C++ library to manipulate bit strings. A comparative survey with other state of the art implementations (such as <em>bitset</em> (STL), or <em>dynamic_biset</em>(BOOST)) may be found <a
href="http://blog.biicode.com/bitscan-efficiency-at-glance/">here</a>. This post brifely describes how BITSCAN operates with sparse bitsets.</p><div
id="attachment_1592" style="width: 295px" class="wp-caption aligncenter"><img
class="wp-image-1592 size-full" src="http://blog.biicode.com/wp-content/uploads/sites/2/2014/09/sparse-bitstrings-bitscan.png" alt="Sparse bitsets in C++ with biicode's library BITSCAN" width="285" height="177" /><p
class="wp-caption-text">Figure 1</p></div><p><span
id="more-1584"></span></p><p>Sparse bitsets are bitstrings with a very high rate of 0-bits. Consider a population set of 1.000 elements (for example production parts per day) from which we want to store a Boolean property (e.g. parts which didn´t pass a specific quality tests). Let´s assume that, in a particular day, only 3 parts were affected. The classical way to deal with such a problem would be to store the 3 elements in an array but if we are interested to <em>reason</em> with that information we might decide on a bitstring encoding. In STL the correct way would look something like this:</p><pre class="crayon-plain-tag">#include &lt;bitset&gt;		//STL implementation for bit strings
void main(){
  bitset&lt;1000&gt; bs;		//fixed population size
  bs.set(0);
  bs.set(1);
  bs.set(2);
}</pre><p>Consider now a production of 1.000.000 parts and again just 3 members in the set. Now bitset&lt;1000000&gt; simply allocates an enormous amount of wasted space. Moreover, reasoning with such degree of sparsity will operate most of the time with empty bit blocks and perform a huge number of spurious bit masking operations.</p><h2>Operating with sparse bitsets</h2><p>BITSCAN treats sparsity as a special case. Internally, sparse bitsets are an ordered array of elements which look similar to the following code (ignore the actual names):</p><pre class="crayon-plain-tag">struct elem{
  int index;				//index of bit block in the bit string
  BITBOARD bb;
}
class SparseBitString{
  vector&lt;elem&gt; bitstring;		//sorted array by index
}</pre><p>&nbsp;</p><p><img
class="size-full wp-image-1668 alignright" src="http://blog.biicode.com/wp-content/uploads/sites/2/2014/09/2421.jpg" alt="Sparse bitsets are weakly coupled and get a special treatment with BITSCAN in biicode." width="397" height="600" />Each element is a bitblock the size of the register word (typically 64 bits) <em>which contains at least a 1-bit</em>; empty bitblocks are simply ignored. Returning to the previous manufacturing example, the sparse bitstring in BITSCAN would only store the single <em>elem</em> {index=0, bb=00000111} for the whole 1.000.000 population.<em> Figure 1</em> shows another example; there a bit string is used to store all the white pawns in a given position. Considering an 8-bit CPU register size, a BITSCAN sparse bit string would only store the 3 non-zero bit-blocks with their corresponding indexes (3, 4, 7) (assume index 1 refers to the bottom block).</p><p>The actual wrappers for sparse bitstrings are the following data types:</p><ul><li><strong>sparse_bitarray</strong>: The main data type which includes all optimizations. In most cases this is the type to be used.</li><li><strong>simple_sparse_bitarray</strong>: A simpler data type to be used only if compiler/HW does not support intrinsics.</li></ul><p>An elementary example of how to use sparse bitsets in BITSCAN is:</p><pre class="crayon-plain-tag">#include "pablodev/bitscan/bitscan.h"	        //one and only header for the BITSCAN block in Biicode
void main(){
  sparse_bitarray sba(1000000);			//size of the population
  sba.set_bit(0);
  sba.set_bit(1);
  sba.set_bit(2);
  //stores just one 64-bit block
}</pre><p>Features currently included for sparse bitsets are oriented towards fast bit scanning. Set union (OR mask) and intersection (AND mask) are also supported. Note that the sparse storage of bitblocks has a penalty on insertion (set_bit is an <em>ordered</em> insertion which runs in logarithmic time) and so does individual bit retrieval (also logarithmic).</p><p>An example of a (<em>non-destructive</em>) bit scan appears below. This is the typical case in which the bit string remains constant. A more efficient form of scanning (<em>destructive</em>) deletes 1-bits as they are scanned. There are many more such examples in the <em>tests </em>folder of the distribution.</p><pre class="crayon-plain-tag">#include "pablodev/bitscan/bitscan.h"	        //one and only header for the BITSCAN block in Biicode
void main(){
  sparse_bitarray sba(1000000);			//size of the population
  //set sba appropiately...
  int nBit=EMPTY_ELEM;
  if(sba.init_scan(bbo::NON_DESTRUCTIVE)!=EMPTY_ELEM){
     while(true){
        nBit=sba.next_bit();
        if(nBit==EMPTY_ELEM) break;
        //int foo = nBit...
     }
  }
}</pre><p>A very important application for sparse bitsets is the <span
style="text-decoration: underline;">encoding of real graphs</span> which tend to be have high order but also tend to be very sparse. The <a
title="GRAPH LIBRARY BIICODE BITSCAN" href="http://www.biicode.com/pablodev/pablodev/graph/master" target="_blank">GRAPH </a> block in the Biicode repository now contains an illustrative wrapper for sparse graphs based on BITSCAN. It is still very much in alpha, but we are developping regularly an it already includes <a
href="http://blog.biicode.com/k-cores-analysis-bitscan/">an efficient implementation of k-Core analysis</a>. A post on sparse graphs and GRAPH will be coming out soon!</p><p>Stay tuned by signing up below</p><div
id="ContainerFriendsSubscribe"><div
class="mc_custom_border_hdr">Stay tuned</div><style>.widget_mailchimpsf_widget .widget-title {
		line-height: 1.4em;
		margin-bottom: 0.75em;
	}
	#mc_subheader {
		line-height: 1.25em;
		margin-bottom: 18px;
	}
	.mc_merge_var {
		margin-bottom: 1.0em;
	}
	.mc_var_label,
	.mc_interest_label {
		display: block;
		margin-bottom: 0.5em;
	}
	.mc_input {
		-moz-box-sizing: border-box;
		-webkit-box-sizing: border-box;
		box-sizing: border-box;
		width: 100%;
	}
	.mc_input.mc_phone {
		width: auto;
	}
	select.mc_select {
		margin-top: 0.5em;
		width: 100%;
	}
	.mc_address_label {
		margin-top: 1.0em;
		margin-bottom: 0.5em;
		display: block;
	}
	.mc_address_label ~ select {
		width: 100%;
	}
	.mc_list li {
		list-style: none;
		background: none !important;
	}
	.mc_interests_header {
		margin-top: 1.0em;
		margin-bottom: 0.5em;
	}
	.mc_interest label,
	.mc_interest input {
		margin-bottom: 0.4em;
	}
	#mc_signup_submit {
		margin-top: 1.5em;
		width: 80%;
	}
	#mc_unsub_link a {
		font-size: 0.75em;
	}
	#mc_unsub_link {
		margin-top: 1.0em;
	}
	.mc_header_address,
	.mc_email_format {
		display: block;
		font-weight: bold;
		margin-top: 1.0em;
		margin-bottom: 0.5em;
	}
	.mc_email_options {
		margin-top: 0.5em;
	}
	.mc_email_type {
		padding-left: 4px;
	}</style><div
id="mc_signup"><form
method="post" action="#mc_signup" id="mc_signup_form"> <input
type="hidden" id="mc_submit_type" name="mc_submit_type" value="html" /> <input
type="hidden" name="mcsf_action" value="mc_submit_signup_form" /> <input
type="hidden" id="_mc_submit_signup_form_nonce" name="_mc_submit_signup_form_nonce" value="528a10d57f" /><div
class="mc_form_inside"><div
class="updated" id="mc_message"></div><div
class="mc_merge_var"> <label
for="mc_mv_EMAIL" class="mc_var_label mc_header mc_header_email">Email Address</label> <input
type="text" size="18" placeholder="" name="mc_mv_EMAIL" id="mc_mv_EMAIL" class="mc_input"/></div><div
class="mc_signup_submit"> <input
type="submit" name="mc_signup_submit" id="mc_signup_submit" value="Send" class="button" /></div></div></form></div></div><p></p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/sparse-bitsets-cpp/">Sparse bitsets in C++ with BITSCAN</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></content:encoded> <wfw:commentRss>http://blog.biicode.com/sparse-bitsets-cpp/feed/</wfw:commentRss> <slash:comments>0</slash:comments> </item> <item><title>Determining k-cores in a network: a new BITSCAN application</title><link>http://blog.biicode.com/k-cores-analysis-bitscan/</link> <comments>http://blog.biicode.com/k-cores-analysis-bitscan/#comments</comments> <pubDate>Thu, 04 Sep 2014 09:45:37 +0000</pubDate> <dc:creator><![CDATA[pablo]]></dc:creator> <category><![CDATA[BITSCAN]]></category> <category><![CDATA[bitscan]]></category> <category><![CDATA[internet graphs]]></category> <category><![CDATA[k-core]]></category> <category><![CDATA[k-cores]]></category> <category><![CDATA[network analysis]]></category> <category><![CDATA[road graphs]]></category> <guid
isPermaLink="false">http://blog.biicode.com/?p=1507</guid> <description><![CDATA[<p>What is k-cores analysis? A major concern of social network analysis is to determine subgroups of actors which cooperate together within a network, in other words from cohesive subsets. To this avail a number of notions were introduced in the past such as cliques,  k-plexes, lambda sets, k-cores etc. Most of these notions are difficult [&#8230;]</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/k-cores-analysis-bitscan/">Determining k-cores in a network: a new BITSCAN application</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></description> <content:encoded><![CDATA[<h2>What is k-cores analysis?</h2><p>A major concern of social network analysis is to determine subgroups of actors which cooperate together within a network, in other words from <em>cohesive subsets</em>. To this avail a number of notions were introduced in the past such as <em>cliques</em>,  <em>k-plexes</em>, <em>lambda sets</em>, <em>k-cores</em> etc. Most of these notions are difficult to compute (non linear and many in NP), but computing cores is the exception because linear algorithms are known to exist<sup><a
id="ref1" href="#fn1">1</a></sup> .This makes k-cores analysis an important source of information for real networks with hundreds of thousands of nodes, such as road graphs, internet graphs etc.</p><div
id="attachment_1508" style="width: 410px" class="wp-caption alignright"><img
class="wp-image-1508" src="http://blog.biicode.com/wp-content/uploads/sites/2/2014/09/k-core-image.png" alt="k-cores decomposition of networks" width="400" height="230" /><p
class="wp-caption-text">k-core decomposition (0-core, 1-core, 2-core, 3-core)</p></div><p
style="text-align: left;"><span
id="more-1507"></span></p><div><p>A<em> k-core</em> (first introduced by Seidy in 1983<sup><a
id="ref2" href="#fn2">2</a>.</sup>) is any induced subgraph in which all its vertices have at least degree <em>k</em> and the subgraph is maximum with this property. The core of maximum order is called the <em>main core</em>. The core number of any vertex is the k-order of the highest core which contains this vertex. Finally the k-core number of a graph is the k-order of its main core. Note that the way degree is defined (in-degree, out-degree, in-degree + out-degree, …) determines different types of cores.</p><div
id="attachment_1511" style="width: 310px" class="wp-caption alignleft"><img
class="wp-image-1511" src="http://blog.biicode.com/wp-content/uploads/sites/2/2014/09/k-core-example-image.png" alt="k-cores example analysis" width="300" height="229" /><p
class="wp-caption-text">A starred network: k-core number is 1</p></div><p>Core analysis is eminently <em>hierarchical</em>, as the above figure (borrowed from [1]) illustrates. The graph in the figure has four cores (0-core, 1-core, 2-core and 3-core) which are depicted in different shades of grey. 0-core is trivially the full graph, while the largest core (3-core) is shaded in the darkest grey. Note that cores do not have to be connected in the general case (e.g. in the figure, the 2-core contains two disconnected subgraphs). In very large sparse graphs k-core analysis typically helps to understand structure better with linear cost. It is much more informative than linear degree related notions. Consider as an example the starred computer network to the left. It is easy to see that the maximum graph degree of the network is 5 (the order of the graph minus 1); in contrast the k-core number is just 1. Note that this automatically gives a 2 upper bound (the k-core number incremented by one) for the clique number of the network as well.</p></div><div><span
style="color: #262626;">Pablo San Segundo, the chess grand master, expert in graphs and PhD IN Artificial Intelligence, has </span>uploaded in the <a
href="https://www.biicode.com/pablodev/pablodev/graph/master">GRAPH repository</a> a SW tool to analyse graph properties. It is located in the pablodev/graph block and has been released as part of the GRAPH library. The aim of this, as yet, small C++ library is to show how to apply the bitstring library <a
href="https://www.biicode.com/pablodev/bitscan">BITSCAN</a> (available exclusively at Biicode) to encode graphs efficiently.  A recent post on basic GRAPH functionality can be found <a
href="http://blog.biicode.com/bit-encoded-graph/">here</a>. More information on how to use GRAPH and BITSCAN to compute k-core decomposition coming soon!</div><div
id="ContainerFriendsSubscribe"><div
class="mc_custom_border_hdr">Stay tuned</div><style>.widget_mailchimpsf_widget .widget-title {
		line-height: 1.4em;
		margin-bottom: 0.75em;
	}
	#mc_subheader {
		line-height: 1.25em;
		margin-bottom: 18px;
	}
	.mc_merge_var {
		margin-bottom: 1.0em;
	}
	.mc_var_label,
	.mc_interest_label {
		display: block;
		margin-bottom: 0.5em;
	}
	.mc_input {
		-moz-box-sizing: border-box;
		-webkit-box-sizing: border-box;
		box-sizing: border-box;
		width: 100%;
	}
	.mc_input.mc_phone {
		width: auto;
	}
	select.mc_select {
		margin-top: 0.5em;
		width: 100%;
	}
	.mc_address_label {
		margin-top: 1.0em;
		margin-bottom: 0.5em;
		display: block;
	}
	.mc_address_label ~ select {
		width: 100%;
	}
	.mc_list li {
		list-style: none;
		background: none !important;
	}
	.mc_interests_header {
		margin-top: 1.0em;
		margin-bottom: 0.5em;
	}
	.mc_interest label,
	.mc_interest input {
		margin-bottom: 0.4em;
	}
	#mc_signup_submit {
		margin-top: 1.5em;
		width: 80%;
	}
	#mc_unsub_link a {
		font-size: 0.75em;
	}
	#mc_unsub_link {
		margin-top: 1.0em;
	}
	.mc_header_address,
	.mc_email_format {
		display: block;
		font-weight: bold;
		margin-top: 1.0em;
		margin-bottom: 0.5em;
	}
	.mc_email_options {
		margin-top: 0.5em;
	}
	.mc_email_type {
		padding-left: 4px;
	}</style><div
id="mc_signup"><form
method="post" action="#mc_signup" id="mc_signup_form"> <input
type="hidden" id="mc_submit_type" name="mc_submit_type" value="html" /> <input
type="hidden" name="mcsf_action" value="mc_submit_signup_form" /> <input
type="hidden" id="_mc_submit_signup_form_nonce" name="_mc_submit_signup_form_nonce" value="528a10d57f" /><div
class="mc_form_inside"><div
class="updated" id="mc_message"></div><div
class="mc_merge_var"> <label
for="mc_mv_EMAIL" class="mc_var_label mc_header mc_header_email">Email Address</label> <input
type="text" size="18" placeholder="" name="mc_mv_EMAIL" id="mc_mv_EMAIL" class="mc_input"/></div><div
class="mc_signup_submit"> <input
type="submit" name="mc_signup_submit" id="mc_signup_submit" value="Send" class="button" /></div></div></form></div></div><p></p><h3>Footnotes</h3><p><sup
id="fn1">1. V. Batagelj and M. Zaversnik, An O(m) algorithm for cores decomposition of networks, cs.DS/0310049, 2003.    <a
title="Jump back to footnote 1 in the text." href="#ref1">↩</a></sup></p><p><sup
id="fn2">2.S. B. Seidman, Network structure and minimum degree, Social Networks, 1983.&#8221;.<a
title="Jump back to footnote 2 in the text." href="#ref2">↩</a></sup></p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/k-cores-analysis-bitscan/">Determining k-cores in a network: a new BITSCAN application</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></content:encoded> <wfw:commentRss>http://blog.biicode.com/k-cores-analysis-bitscan/feed/</wfw:commentRss> <slash:comments>1</slash:comments> </item> <item><title>Bit-encoded Graphs</title><link>http://blog.biicode.com/bit-encoded-graph/</link> <comments>http://blog.biicode.com/bit-encoded-graph/#comments</comments> <pubDate>Thu, 31 Jul 2014 08:30:26 +0000</pubDate> <dc:creator><![CDATA[pablo]]></dc:creator> <category><![CDATA[biicoders]]></category> <category><![CDATA[news]]></category> <category><![CDATA[bit set]]></category> <category><![CDATA[bit string]]></category> <category><![CDATA[bitarray]]></category> <category><![CDATA[c++]]></category> <category><![CDATA[cpp]]></category> <category><![CDATA[graph]]></category> <category><![CDATA[np-hard]]></category> <guid
isPermaLink="false">http://blog.biicode.com/?p=969</guid> <description><![CDATA[<p>UPDATED: 11/09/2014 Today, by the hand of Pablo San Segundo, we present graph and ugraph, two simple, easy-to-use, C++ wrappers for unweighted graphs encoded as bit strings. Preliminaries One of the most interesting and versatile applications of bit strings is to encode simple unweighted graphs dynamic in the number of edges (i.e. there is an [&#8230;]</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/bit-encoded-graph/">Bit-encoded Graphs</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></description> <content:encoded><![CDATA[<p>UPDATED: 11/09/2014</p><p>Today, by the hand of <a
title="Pablo San Segundo" href="http://es.wikipedia.org/wiki/Pablo_San_Segundo_Carrillo" target="_blank">Pablo San Segundo</a>, we present g<em>raph</em> and <em>ugraph</em>, two simple, easy-to-use, C++ wrappers for unweighted graphs encoded as bit strings.</p><h2>Preliminaries</h2><p>One of the most interesting and versatile applications of bit strings is to encode simple unweighted graphs dynamic in the number of edges (i.e. there is an efficient way to add/remove edges but not so for the vertices). Graphs encoded as bit strings have recently attracted the attention of researchers in relation to  well known NP-hard problems such as <em>vertex coloring</em> or <em>clique</em>. The main reason is that efficient algorithms that exploit bit-parallelism at CPU level have been found for such problems.</p><p><span
id="more-969"></span></p><p>The figure shows a simple undirected graph with 6 vertices (in red a 3-clique).  The last two columns show the bit encoding of the adjacency matrix of the graph. Each 1-bit refers to an edge in the graph and each bit string encodes the neighbor set of the corresponding vertex.</p><p><img
class="aligncenter wp-image-970" src="http://blog.biicode.com/wp-content/uploads/sites/2/2014/07/ugraph-pablo-exmple-bitstring.png" alt="ugraph pablo exmple bitstring" width="630" height="240" /></p><p>For example, the bitstring for V1 is 010010, which indicates that V2 and V5 are its neighbors (we assume bit positions start at 1 and increase from left to right).</p><h2>graph CLASS</h2><p>A graph object refers to a (bit-encoded) simple directed graph. In the current version it is possible either to create an empty graph of any order (and add or remove edges manually) or to read a graph in DIMACS format from a text file.</p><p>Here is an example:</p><pre class="crayon-plain-tag">#include "pablodev/graph/graph.h"   //header for the block in Biicode repository
graph g1("brock200_1.clq");         //reads the file in g1
graph g2(3);                        //creates a 3-clique in g2
g2.add_edge(0,1);
g2.add_edge(1,2);
g2.add_edge(0,3);</pre><p><em>graph</em> includes a number of functionalities related to graph configuration, examples of which can be found in the <em>test_graph.cpp</em> file inside the <em>tests</em> folder of the distribution. Adding and removing edges can be done in constant time. However removing vertices modifies the adjacency matrix and requires memory reallocation.</p><p>It is important to remember that graph objects are by default <em>directed</em> (the adjacency matrix is not symmetrical). If you want to ensure that edges are symmetrical use the <em>make_bidirected</em> member function.</p><h2>ugraph CLASS</h2><p>The <em>u</em>g<em>raph</em> class is a specialization of the <em>graph</em> class for undirected graphs. Each time an edge is added to the graph (with the <em>add_edge</em> function) it is always symmetrical. Moreover a number of functions can be implemented more efficiently for the undirected case and have been overridden for <em>graph</em>, such as logical checking for equality, edge processing etc. As before  we refer the reader to the <em>test_graph.cpp</em> file for examples of code.</p><h2>APPLICATIONS</h2><p>The <em>ugraph</em> class has been used to implement <em>BBMC</em>, a leading state of the art algorithm for the maximum clique problem known to be NP-hard. A number of variants for BBMC are described in literature <sup><a
id="ref1" href="#fn1">1</a></sup> <sup><a
id="ref2" href="#fn2">2</a></sup> <sup><a
id="ref3" href="#fn3">3</a></sup><br
/> . BBMC has also been applied successfully to approximate vertex coloring  and exact coloring <sup><a
id="ref4" href="#fn4">4</a></sup>. Finally some applications for real problems related to matching can be found in <sup><a
id="ref5" href="#fn5">5</a> </sup><sup><a
id="ref6" href="#fn6">6</a></sup>.</p><p><a
title="Graph Ugraph classes bit-encoding" href="http://www.biicode.com/pablodev/pablodev/graph/master" target="_blank"><em>graph</em> and <em>ugraph</em> types are available exclusively at Biicode. </a>We make them public for researchers and practitioners which are interested in combinatorial problem solving and as an example of  bit string graph encoding. We also hope that Biicode´s reuse paradigm helps to add new exciting features!</p><p>&nbsp;</p><h3>Footnotes</h3><p><sup
id="fn1">1.    San Segundo, P. Rodriguez-Losada, D., Jimenez, A.; <em>An exact bit-parallel algorithm for the maximum clique problem</em>. Computers &amp; Operations Research  38:2, 2011, 571-581.<a
title="Jump back to footnote 1 in the text." href="#ref1">↩</a></sup></p><p><sup
id="fn2">2.    San Segundo, P. Matia, F., Rodriguez-Losada, D., Hernando, M.; <em>An improved bit parallel exact maximum clique algorithm.</em> Optimization Letters.  7:3, Springer 2011, 467-479.<a
title="Jump back to footnote 2 in the text." href="#ref2">↩</a></sup></p><p><sup
id="fn3">3.      San Segundo, P., Tapia, C. <em>Relaxed approximate coloring in exact maximum clique search. </em><em>Computers &amp; Operations Research</em>, 44, 2014, 185-192.<a
title="Jump back to footnote 3 in the text." href="#ref3">↩</a></sup></p><p><sup
id="fn4">4.      San Segundo, P. <em>A new DSATUR-based algorithm for exact vertex coloring</em>. Computers &amp; Operations Research, 39:7, 2012, 1724-1733.<a
title="Jump back to footnote 4 in the text." href="#ref4">↩</a></sup></p><p><sup
id="fn5">5.      San Segundo, P., Rodriguez-Losada, D., Matia, F., Galan, R. <em>Fast exact feature based data correspondence search with an efficient bit-parallel MCP solver</em>. Applied Intelligence, 32:3, 2010, 311-329.<a
title="Jump back to footnote 5 in the text." href="#ref5">↩</a></sup></p><p><sup
id="fn6">6.      San Segundo, P., Rodriguez-Losada, D. <em>Robust Global Feature Based Data Association With a Sparse Bit Optimized Maximum Clique Algorithm</em>.  IEEE Transactions on Robotics, 29:5, 2013, 1332-1339.<a
title="Jump back to footnote 6 in the text." href="#ref6">↩</a></sup><br
/></p><div
id="ContainerFriendsSubscribe"><div
class="mc_custom_border_hdr">Stay tuned</div><style>.widget_mailchimpsf_widget .widget-title {
		line-height: 1.4em;
		margin-bottom: 0.75em;
	}
	#mc_subheader {
		line-height: 1.25em;
		margin-bottom: 18px;
	}
	.mc_merge_var {
		margin-bottom: 1.0em;
	}
	.mc_var_label,
	.mc_interest_label {
		display: block;
		margin-bottom: 0.5em;
	}
	.mc_input {
		-moz-box-sizing: border-box;
		-webkit-box-sizing: border-box;
		box-sizing: border-box;
		width: 100%;
	}
	.mc_input.mc_phone {
		width: auto;
	}
	select.mc_select {
		margin-top: 0.5em;
		width: 100%;
	}
	.mc_address_label {
		margin-top: 1.0em;
		margin-bottom: 0.5em;
		display: block;
	}
	.mc_address_label ~ select {
		width: 100%;
	}
	.mc_list li {
		list-style: none;
		background: none !important;
	}
	.mc_interests_header {
		margin-top: 1.0em;
		margin-bottom: 0.5em;
	}
	.mc_interest label,
	.mc_interest input {
		margin-bottom: 0.4em;
	}
	#mc_signup_submit {
		margin-top: 1.5em;
		width: 80%;
	}
	#mc_unsub_link a {
		font-size: 0.75em;
	}
	#mc_unsub_link {
		margin-top: 1.0em;
	}
	.mc_header_address,
	.mc_email_format {
		display: block;
		font-weight: bold;
		margin-top: 1.0em;
		margin-bottom: 0.5em;
	}
	.mc_email_options {
		margin-top: 0.5em;
	}
	.mc_email_type {
		padding-left: 4px;
	}</style><div
id="mc_signup"><form
method="post" action="#mc_signup" id="mc_signup_form"> <input
type="hidden" id="mc_submit_type" name="mc_submit_type" value="html" /> <input
type="hidden" name="mcsf_action" value="mc_submit_signup_form" /> <input
type="hidden" id="_mc_submit_signup_form_nonce" name="_mc_submit_signup_form_nonce" value="528a10d57f" /><div
class="mc_form_inside"><div
class="updated" id="mc_message"></div><div
class="mc_merge_var"> <label
for="mc_mv_EMAIL" class="mc_var_label mc_header mc_header_email">Email Address</label> <input
type="text" size="18" placeholder="" name="mc_mv_EMAIL" id="mc_mv_EMAIL" class="mc_input"/></div><div
class="mc_signup_submit"> <input
type="submit" name="mc_signup_submit" id="mc_signup_submit" value="Send" class="button" /></div></div></form></div></div><p></p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/bit-encoded-graph/">Bit-encoded Graphs</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></content:encoded> <wfw:commentRss>http://blog.biicode.com/bit-encoded-graph/feed/</wfw:commentRss> <slash:comments>1</slash:comments> </item> <item><title>A quick approach to BITSCAN</title><link>http://blog.biicode.com/quick-approach-bitscan/</link> <comments>http://blog.biicode.com/quick-approach-bitscan/#comments</comments> <pubDate>Fri, 25 Jul 2014 08:00:40 +0000</pubDate> <dc:creator><![CDATA[pablo]]></dc:creator> <category><![CDATA[try this out]]></category> <category><![CDATA[biicode]]></category> <category><![CDATA[bitscan]]></category> <category><![CDATA[c/c++]]></category> <category><![CDATA[c/cpp]]></category> <category><![CDATA[c++]]></category> <category><![CDATA[chess]]></category> <category><![CDATA[combinatorial problems]]></category> <category><![CDATA[control inteligente]]></category> <category><![CDATA[cpp]]></category> <category><![CDATA[features]]></category> <guid
isPermaLink="false">http://blog.biicode.com/?p=922</guid> <description><![CDATA[<p>Pablo San Segundo, professor of Robotics at UPM in Madrid, after years of scientific investigation and many hours of devoted work on his passion: chess (he's a Chess Grandmaster), have lead him to propose BITSCAN library as a help with many complex combinatorial problems. He has been using BITSCAN with the help of biicode and it works just fine. It has clearly  proved to be more efficient than other implementations widespread in the developer community. Give it a try!</p><p><a
href="http://blog.biicode.com/quick-approach-bitscan/"> Read More...</a></p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/quick-approach-bitscan/">A quick approach to BITSCAN</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></description> <content:encoded><![CDATA[<p>This is is a small explanation about BITSCAN, the C++ library exclusively developed by <a
title="Pablo San Segundo" href="http://es.wikipedia.org/wiki/Pablo_San_Segundo_Carrillo" target="_blank">Pablo San Segundo</a>.</p><p>BITSCAN is dedicated to the efficient processing of bit strings. In programming, a bit string is a data structure that stores collections of 1s and 0s. It gets interesting when those 1s and 0s refer to a Boolean property of a group, so that each element of this group is identified by a bit of that chain.</p><h2>Time to move your pawns forward</h2><p>A good example of this is the game of chess. In a chessboard each position is formed by six different types of pieces with two possible colours. A string of 64 bits can encode the position of all pieces of the same type and color on the board (e.g. &#8220;white pawns&#8221;) by referring each bit to a square with the semantics of a value to 1 (TRUE) if the square is occupied by a piece of the chosen type and 0 (FASLE) otherwise.<span
id="more-922"></span></p><p>The figure below shows an example. The white pawns on the board are encoded the 64-bit string to the right.<br
/> <img
class="aligncenter wp-image-923" src="http://blog.biicode.com/wp-content/uploads/sites/2/2014/07/bitscan-example-blogpost.png" alt="bitscan example blogpost" width="630" height="346" /><br
/> Recently bit strings have had much impact in the scientific community because it has been shown that bit-parallel algorithms can accelerate up to one order of magnitude the solution of a number of complex combinatorial problems.<br
/> After years of research in combinatorial optimization, Professor San Segundo has developed C++ bit string library BITSCAN optimizing those features that he found useful in his work, including different types of bit scanning.</p><h3>More on BITSCAN</h3><p>As you can recall, in a recent <a
title="survey BITSCAN" href="http://blog.biicode.com/bitscan-efficiency-at-glance/">comparative</a> BITSCAN was proven clearly more efficient than other C, C++ widespread implementations (i.e. STL bitset and BOOST dynamic_bitset).</p><p>Are you interested in scanning bits? Pablo is going to release soon a great surprise for those interested in encoding simple unweighted graphs.</p><p>Stay tuned!<br
/></p><div
id="ContainerFriendsSubscribe"><div
class="mc_custom_border_hdr">Stay tuned</div><style>.widget_mailchimpsf_widget .widget-title {
		line-height: 1.4em;
		margin-bottom: 0.75em;
	}
	#mc_subheader {
		line-height: 1.25em;
		margin-bottom: 18px;
	}
	.mc_merge_var {
		margin-bottom: 1.0em;
	}
	.mc_var_label,
	.mc_interest_label {
		display: block;
		margin-bottom: 0.5em;
	}
	.mc_input {
		-moz-box-sizing: border-box;
		-webkit-box-sizing: border-box;
		box-sizing: border-box;
		width: 100%;
	}
	.mc_input.mc_phone {
		width: auto;
	}
	select.mc_select {
		margin-top: 0.5em;
		width: 100%;
	}
	.mc_address_label {
		margin-top: 1.0em;
		margin-bottom: 0.5em;
		display: block;
	}
	.mc_address_label ~ select {
		width: 100%;
	}
	.mc_list li {
		list-style: none;
		background: none !important;
	}
	.mc_interests_header {
		margin-top: 1.0em;
		margin-bottom: 0.5em;
	}
	.mc_interest label,
	.mc_interest input {
		margin-bottom: 0.4em;
	}
	#mc_signup_submit {
		margin-top: 1.5em;
		width: 80%;
	}
	#mc_unsub_link a {
		font-size: 0.75em;
	}
	#mc_unsub_link {
		margin-top: 1.0em;
	}
	.mc_header_address,
	.mc_email_format {
		display: block;
		font-weight: bold;
		margin-top: 1.0em;
		margin-bottom: 0.5em;
	}
	.mc_email_options {
		margin-top: 0.5em;
	}
	.mc_email_type {
		padding-left: 4px;
	}</style><div
id="mc_signup"><form
method="post" action="#mc_signup" id="mc_signup_form"> <input
type="hidden" id="mc_submit_type" name="mc_submit_type" value="html" /> <input
type="hidden" name="mcsf_action" value="mc_submit_signup_form" /> <input
type="hidden" id="_mc_submit_signup_form_nonce" name="_mc_submit_signup_form_nonce" value="528a10d57f" /><div
class="mc_form_inside"><div
class="updated" id="mc_message"></div><div
class="mc_merge_var"> <label
for="mc_mv_EMAIL" class="mc_var_label mc_header mc_header_email">Email Address</label> <input
type="text" size="18" placeholder="" name="mc_mv_EMAIL" id="mc_mv_EMAIL" class="mc_input"/></div><div
class="mc_signup_submit"> <input
type="submit" name="mc_signup_submit" id="mc_signup_submit" value="Send" class="button" /></div></div></form></div></div><p></p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/quick-approach-bitscan/">A quick approach to BITSCAN</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></content:encoded> <wfw:commentRss>http://blog.biicode.com/quick-approach-bitscan/feed/</wfw:commentRss> <slash:comments>0</slash:comments> </item> </channel> </rss>