<?xml version="1.0" encoding="UTF-8"?><rss
version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:wfw="http://wellformedweb.org/CommentAPI/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
> <channel><title>biicode Blog &#187; CppMicroServices</title> <atom:link href="http://blog.biicode.com/tag/cppmicroservices/feed/" rel="self" type="application/rss+xml" /><link>http://blog.biicode.com</link> <description>Almost daily C and C++ jibby jabba</description> <lastBuildDate>Sun, 16 Aug 2015 07:58:20 +0000</lastBuildDate> <language>en-US</language> <sy:updatePeriod>hourly</sy:updatePeriod> <sy:updateFrequency>1</sy:updateFrequency> <generator>http://wordpress.org/?v=4.2.5</generator> <item><title>Lessons learnt adapting CppMicroServices to biicode</title><link>http://blog.biicode.com/cppmicroservices-biicode/</link> <comments>http://blog.biicode.com/cppmicroservices-biicode/#comments</comments> <pubDate>Wed, 11 Feb 2015 15:41:31 +0000</pubDate> <dc:creator><![CDATA[azriel]]></dc:creator> <category><![CDATA[biicode-internals]]></category> <category><![CDATA[biicoders]]></category> <category><![CDATA[CppMicroServices]]></category> <category><![CDATA[upload libraries to biicode]]></category> <category><![CDATA[upload to biicode]]></category> <guid
isPermaLink="false">http://blog.biicode.com/?p=2058</guid> <description><![CDATA[<p>This post summarizes the lessons learnt from adapting the CppMicroServices framework to a biicode compatible format. It does not go into detail about the actual modifications, but focuses on the lessons learnt adapting the framework. Background CppMicroServices is an implementation of the OSGi framework, which enables runtime dependency injection. Modules of code (bundles) can be [&#8230;]</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/cppmicroservices-biicode/">Lessons learnt adapting CppMicroServices to biicode</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></description> <content:encoded><![CDATA[<p>This post summarizes the lessons learnt from adapting the <a
href="http://cppmicroservices.org/" target="_blank">CppMicroServices</a> framework to a biicode compatible format. It does not go into detail about the actual modifications, but focuses on the lessons learnt adapting the framework.</p><h2><a
class="anchor" href="https://gist.github.com/azriel91/95d5c90ff34834380afe#background" rel="noreferrer" name="user-content-tools"></a>Background</h2><p>CppMicroServices is an implementation of the OSGi framework, which enables runtime dependency injection. Modules of code (bundles) can be loaded and unloaded at runtime. In the case of CppMicroServices, bundles are either shipped in the form of shared libraries, or statically linked into the executable.</p><p><img
class="aligncenter wp-image-2067 size-medium" src="http://blog.biicode.com/wp-content/uploads/sites/2/2015/02/cppmicroservices-300x60.png" alt="cppmicroservices" width="300" height="60" /></p><p>Based on <a
href="http://en.wikipedia.org/wiki/Package_principles" rel="noreferrer">packaging principles</a>, bundles should be packaged and released separately &#8211; so that they can be depended on individually. biicode&#8217;s dependency management through blocks is suitable as a <a
href="http://blog.biicode.com/file-based-cpp-dependency-manager/" target="_blank">dependency management tool</a> that supports this flow.</p><p><span
id="more-2058"></span></p><h2><a
class="anchor" href="https://gist.github.com/azriel91/95d5c90ff34834380afe#lessons-learnt-while-adapting-the-cppmicroservices-framework" rel="noreferrer" name="user-content-lessons-learnt-while-adapting-the-cppmicroservices-framework"></a>Lessons Learnt While Adapting the CppMicroServices Framework</h2><p>Never learn two things at once. This is one of the most important rules to obey when attempting a migration / modification. Another rule is to understand the specifics of each entity involved in the task &#8211; not just the concepts, but the concrete behaviour.</p><p>In my case, I understood the concepts of build and dependency management tools, but I was not familiar with biicode, CMake, and how CppMicroServices used CMake.</p><h3><a
class="anchor" href="https://gist.github.com/azriel91/95d5c90ff34834380afe#tools" rel="noreferrer" name="user-content-tools"></a>Tools</h3><p>There are multiple layers of tools involved in a biicode build. biicode, CMake, Make, and the compiler (g++, clang, cl) and linker. When something fails, understand why it fails. It&#8217;s not always the lowest layer&#8217;s fault. Perhaps some CMake configuration wasn&#8217;t written to tell <code>ld</code> that a particular library needs to be linked.</p><h4><a
class="anchor" href="https://gist.github.com/azriel91/95d5c90ff34834380afe#biicode" rel="noreferrer" name="user-content-biicode"></a>biicode</h4><p>Of all of the components in play, biicode probably has the shallowest learning curve &#8211; for the most part. biicode&#8217;s documentation makes it easy to see how it works for freshly created blocks. The hard part is determining if it can do <em>some complex thing that isn&#8217;t documented</em>. The short answer is no, <a
href="http://docs.biicode.com/c++/building.html#init-biicode-block" rel="noreferrer">what is documented</a> is what you get &#8211; but I found that this is enough. The trickiest part is populating the variables that biicode will read.</p><p>The <a
href="http://forum.biicode.com/" rel="noreferrer">forum</a> is also a very helpful place to get your questions answered.</p><h4><a
class="anchor" href="https://gist.github.com/azriel91/95d5c90ff34834380afe#cmake" rel="noreferrer" name="user-content-cmake"></a>CMake</h4><p>CMake reads like a bash script &#8211; short sections are relatively easily understood, but once it gets big, navigating and understanding the code is a hassle. A few gotchas that mask obscure errors when CMake builds fail are:</p><ul
class="task-list"><li><code>function_call(${param1} ${param2} ${param3})</code> is effectively <code>function_call(${param1} ${param3})</code> if <code>${param2}</code> is empty</li><li>if a subdirectory is added as part of a CMake build using add_subdirectory(<em>dirname</em>), it is in a scope where it is able to access variables set in the parent directory scope, but any variables set in this scope will not be accessible to the parent directory unless <code>PARENT_SCOPE</code> is passed to the function</li></ul><h4><a
class="anchor" href="https://gist.github.com/azriel91/95d5c90ff34834380afe#mixing-biicode-and-cmake" rel="noreferrer" name="user-content-mixing-biicode-and-cmake"></a>Mixing biicode and CMake</h4><p>If the project to be converted produces multiple artifacts, biicode needs the source files for its targets to be declared in the relevant BII_artifactname_SRC variables. This must be done before the <code>ADD_BIICODE_TARGETS()</code> function is called.</p><p>If a target&#8217;s source includes generated files, then the path to those generated files must be known before the target is added (i.e. prior to the <code>ADD_BIICODE_TARGETS()</code> call). If there is special processing required for a biicode target in a subdirectory, but that subdirectory is added before <code>ADD_BIICODE_TARGETS()</code> is called, then this cannot be done. Either:</p><ul
class="task-list"><li>create a different static library target in the subdirectory, and link this to the biicode target instead, OR</li><li>perform that special processing in the parent directory&#8217;s CMake configuration after the biicode targets are added (may result in duplicated code)</li></ul><h3><a
class="anchor" href="https://gist.github.com/azriel91/95d5c90ff34834380afe#building-and-testing" rel="noreferrer" name="user-content-building-and-testing"></a>Building and Testing</h3><h4><a
class="anchor" href="https://gist.github.com/azriel91/95d5c90ff34834380afe#build-each-combination" rel="noreferrer" name="user-content-build-each-combination"></a>Build each combination</h4><p>After making changes to the project, it is important to make sure it builds on the following combinations:</p><ul
class="task-list"><li>The non-biicode build</li><li>From the repository checkout (e.g. git clone)</li><li>From bii open user/block &#8211; in case required files are not published</li><li>From a block that depends on it &#8211; to discover implicit source dependencies that cannot be discovered by biicode</li></ul><h4><a
class="anchor" href="https://gist.github.com/azriel91/95d5c90ff34834380afe#build-on-each-operating-system" rel="noreferrer" name="user-content-build-on-each-operating-system"></a>Build on each operating system</h4><p>If your block should support different operating systems, you should build it on each to ensure it works. This also lets you discover how the block must be built. For example, CMake may default to the MINGW compiler on Windows,but your block may only support the MSVC compiler. This means you need to add an argument to the build command, e.g. <code>bii cpp:configure -G "Visual Studio 12 2013 Win64""</code>.</p><p><strong>Tip:</strong> CMake does not detect your MSVC compiler if <em>&#8220;Express 2013 for Windows&#8221;</em> is installed, but it does if <em>&#8220;Express 2013 for Windows Desktop&#8221;</em> is installed.</p><h4><a
class="anchor" href="https://gist.github.com/azriel91/95d5c90ff34834380afe#clean-your-working-directory" rel="noreferrer" name="user-content-clean-your-working-directory"></a>Clean your working directory</h4><p>Before you build with biicode, make sure you clean out any output from a non-biicode build (e.g. CMakeCache.txt, generated files).</p><pre class="crayon-plain-tag">git clean -fd # warning: this removes all untracked files, so commit / stage them before running this command</pre><p><strong>Tip:</strong> you can use <code>cmake -Bbuild -H.</code> to have an &#8220;out of source&#8221; build. After, run <code>cd build &amp;&amp; make all &amp;&amp; cd ..</code> to compile your code. Just delete the <code>build</code> directory to clean up your working directory.</p><h3><a
class="anchor" href="https://gist.github.com/azriel91/95d5c90ff34834380afe#post-publishing-actions" rel="noreferrer" name="user-content-post-publishing-actions"></a>Post Publishing Actions</h3><p>After publishing a block as stable, the next time you publish, your ancestor version for your block is bumped. Remember to commit this change shortly after.</p><h3>Author Bio</h3><p>Azriel is a software developer at Orion Health in New Zealand. His interest in C/C++ development is primarily driven by the control available in the language, and the opportunity to demonstrate that C/C++ code can be clean. To Azriel, biicode is a major improvement to dependency management in C/C++ projects, and compares the improvement in dependency management support from CMake to biicode akin to Apache Ivy to Apache Maven.</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/cppmicroservices-biicode/">Lessons learnt adapting CppMicroServices to biicode</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></content:encoded> <wfw:commentRss>http://blog.biicode.com/cppmicroservices-biicode/feed/</wfw:commentRss> <slash:comments>0</slash:comments> </item> </channel> </rss>