<?xml version="1.0" encoding="UTF-8"?><rss
version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:wfw="http://wellformedweb.org/CommentAPI/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
> <channel><title>biicode Blog &#187; Massive real graphs</title> <atom:link href="http://blog.biicode.com/tag/massive-real-graphs/feed/" rel="self" type="application/rss+xml" /><link>http://blog.biicode.com</link> <description>Almost daily C and C++ jibby jabba</description> <lastBuildDate>Sun, 16 Aug 2015 07:58:20 +0000</lastBuildDate> <language>en-US</language> <sy:updatePeriod>hourly</sy:updatePeriod> <sy:updateFrequency>1</sy:updateFrequency> <generator>http://wordpress.org/?v=4.2.5</generator> <item><title>Exact maximum clique for large or massive real graphs continued</title><link>http://blog.biicode.com/exact-maximum-clique-for-massive-real-graphs/</link> <comments>http://blog.biicode.com/exact-maximum-clique-for-massive-real-graphs/#comments</comments> <pubDate>Wed, 08 Apr 2015 09:23:34 +0000</pubDate> <dc:creator><![CDATA[pablo]]></dc:creator> <category><![CDATA[algorithms]]></category> <category><![CDATA[biicode]]></category> <category><![CDATA[BBMCSP algorithm]]></category> <category><![CDATA[Exact maximum clique]]></category> <category><![CDATA[Massive real graphs]]></category> <guid
isPermaLink="false">http://blog.biicode.com/?p=2164</guid> <description><![CDATA[<p>The excellent performance reported by BBMCSP—an exact maximum clique algorithm tailored for massive real networks— in a previous post has raised a number of comments, some even questioning either the report itself or the problem’s complexity. This post gives an insight on how BBMCSP works. In the process, and similar to what happens when magicians [&#8230;]</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/exact-maximum-clique-for-massive-real-graphs/">Exact maximum clique for large or massive real graphs continued</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></description> <content:encoded><![CDATA[<p>The excellent performance reported by BBMCSP—an exact maximum clique algorithm tailored for massive real networks— in a <a
href="http://blog.biicode.com/maximum-clique-for-massive-sparse-graphs/">previous post</a> has raised a number of comments, some even questioning either the report itself or the problem’s complexity. This post gives an insight on how BBMCSP works. In the process, and similar to what happens when magicians explain their tricks, we are aware that some of the magic will be lost.</p><p><span
id="more-2164"></span></p><p>BBMCSP’s overarching ideas are described in the pseudocode below:</p><h2><strong>BBMCSP: an exact maximum clique algorithm</strong></h2><p><em>Input</em>: A simple graph G(V, E)<br
/> <em>Output</em>: A maximum clique in G in S<sub>max</sub></p><ol><li>Compute k-core decomposition of G: K(G)</li><li>Compute an initial clique greedily: S<sub>max</sub></li><li>Remove vertices from G such that K(v)&lt;|S<sub>max</sub>|: G<sub>r </sub>(V<sub>r</sub>, E<sub>r</sub>)</li><li>Sort V<sub>r</sub> according to degeneracy</li><li>Iteratively branch on vertices in Vr in reverse order: v</li><li>|    Compute subproblem derived from v: W ⊆ V<sub>r</sub></li><li>|    Compute a greedy coloring of W : C(W). <strong>if</strong> |C(W)|&lt; |S<sub>max</sub>| <strong>return</strong></li><li>|    Compute k-core decomposition of W : K(W).<strong> if</strong> |K(W)|&lt; |S<sub>max</sub>| <strong>return</strong></li><li>|    Remove vertices w from W such that K(w)&lt;|S<sub>max</sub>|: W’</li><li>|    Sort W’ according to degeneracy</li><li>|    SEARCH for a maximum clique in W’ with BBMC sparse solver : S<sub>max</sub></li><li>|_ Remove v from V<sub>r</sub></li><li><strong>return</strong> S<sub>max</sub></li></ol><h3><strong> STEP BY STEP</strong></h3><p>All steps except 11 constitute preprocessing tailored for massive graphs. Core hierarchical decomposition in step 1 is a must for any decent graph software package. Each k-core determines a maximal subgraph with the property that all its vertices have degree at least k (cf. <a
href="http://blog.biicode.com/maximum-clique-for-massive-sparse-graphs/">previous post</a>). Thus, the core number of a vertex is the order the highest core which contains it and the core number of the graph is the order of its highest core.  Note that, in the case of real graphs, the core number is usually much lower than the maximum degree of the graph—e.g. in networks with a power law distribution only a few individuals are massively connected—. Step 3 removes vertices that cannot possibly improve the initial greedy clique in S<sub>max</sub> because of a low core number. After that vertices are sorted in step 4 according to degeneracy, i.e. non increasing core number.</p><p>Step 5 is the main loop which may be regarded as a first level unrolling of the search tree of a typical exact solver. For each vertex v picked in reverse order, the child subproblem—its neighbor set— is also preprocessed trying to produce an early cut. Step 7 is concerned with approximate color cuts, i.e. the current best solution in S<sub>max</sub> cannot be improved by any subproblem in which a coloring of size less than | S<sub>max</sub>|.  Moreover, Step 8 prunes the subproblem if its core number is less than| S<sub>max</sub>|.  Finally, if the subproblem cannot be pruned directly in the previous two steps, concrete vertices are removed when their core number is less than | S<sub>max</sub>| in step 9. Remaining vertices are sorted by degeneracy in step 10.</p><p>The actual NP-hard search occurs in step 11 over the filtered subproblem W&#8217;. BBMCSP uses the exact bitstring solver BBMC tailored for large or massive graphs by a specifically designed sparse encoding, as mentioned in the alluded <a
href="http://blog.biicode.com/maximum-clique-for-massive-sparse-graphs/">previous post</a>.</p><h3><strong>AN EXAMPLE</strong></h3><div
id="attachment_2169" style="width: 640px" class="wp-caption aligncenter"><img
class="wp-image-2169 size-large" src="http://blog.biicode.com/wp-content/uploads/sites/2/2015/04/GraphExample-1024x585.png" alt="An example of a graph being used to solve the exact maximum clique problem." width="630" height="360" /><p
class="wp-caption-text">Figure 1. A Graph example. Label notation &lt;x:y:z&gt; denotes vertex index, kcore and degree respectively</p></div><p>Figure 1 contains a simple graph G of order 10 &#8211;notation for node labels x:y:x is <em>x</em> for index, <em>y</em> for kcore number and <em>z</em> for degree&#8211;. The graph core number K(G) is 4 and its maximum degree is 6 (given by vertex 6). Step 2 of the algorithm finds an initial greedy clique | S<sub>max</sub>| of  3 so vertices 1 and 5 are explicitly removed  from G in step 3. The remaining vertices are ordered according to degeneracy in step 4 (see figure 1, left).</p><p>Figure 2 below contains the resulting behaviour of BBMCSP in the main loop (steps 5-12), which includes the first level unrolling and the actual NP-hard search. Vertices are picked in reverse order (header <em>v</em>) and, after each iteration, removed from G<sub>r </sub>. The first iteration in the loop calls vertex 8 and analyses subproblem W={2, 3, 5, 7}. The vertex coloring C(W)  has color size 3, same as   | S<sub>max</sub>| so the subproblem cannot be pruned at step 7. The subproblem <em>is </em>pruned, however, in step 8 by core analysis. Subsequently vertex 8 is removed and vertex 7 startsa new iteration (second row).</p><p>The critical step occurs when vertex 6 is chosen, which contains a maximum clique {1, 2, 4, 6}. In this case the entire subproblem cannot obviously be pruned so vertex 9 is reached and vertex 5 is removed since K(5) is lower than | S<sub>max</sub>|. The search routine is finally called in step 11 and the clique si found. Remaining vertices in G<sub>r </sub>are pruned more or less trivially thereafter.</p><div
id="attachment_2174" style="width: 838px" class="wp-caption aligncenter"><img
class="wp-image-2174" src="http://blog.biicode.com/wp-content/uploads/sites/2/2015/04/BBMCSP_search.png" alt="BBMCSP steps 5-12 taken in the exact maximum clique problem solving" width="828" height="313" /><p
class="wp-caption-text">Figure 2. BBMCSP steps 5-12</p></div><h3><strong>IMPLEMENTATION DETAILS</strong></h3><p>K-core analysis is critical during preprocessing. If the reader wants to implement it by himself we warn him that the typical solution runs in O(|V|<sup>2</sup>) which is not adequate for large or massive sparse graphs. We recommend the O(|E|) algorithm of <a
href="http://vlado.fmf.uni-lj.si/pub/networks/doc/cores/cores.pdf">Bagatelij</a>—the  implementation used by BBMCSP can be found in the <a
href="https://www.biicode.com/pablodev/graph">pablodev/graph</a> block in the Biicode repo—. A side result is that vertices are also sorted according to degeneracy, which is necessary for steps 4 and 10 as explained.</p><p>A sequential greedy coloring in step 7 assigns, to each vertex in turn, the lowest possible color label consistent with the current partial coloring. The bitstring implementation employed by BBMCSP may be found in the <a
href="https://www.biicode.com/pablodev/copt">pablodev/copt</a> block (<em>InitColor</em> class).</p><p>Additionally, the sparse encoding used by BBMC is available as part of the BITSCAN library—<a
href="https://www.biicode.com/pablodev/bitscan">pablodev/bitscan</a> block— and the GRAPH library—pablodev/graph— block. BBMCSP uses the sparse_graph available in GRAPH and currently most of the source code is also available in the pablodev/copt block.</p><h4><strong>A NOTE ON COMPLEXITY</strong></h4><p>In reply to the comments of some of our readers, maximum clique is <em>still</em> NP-hard, yes, and uniform graphs of say a thousand vertices and 0.8 density remain a very difficult challenge for today’s best exact solvers. The reason why BBMCSP is so successful lies mainly on the structure of real networks, which is typically much simplified after the heavy tailored preprocessing described.</p><p>That this is so can be seen in the following example: the California road network <em>roadNet-CA</em> with 1.9 million nodes, 2.7 million edges and a clique number of 4 was trivially solved in less than a second of preprocessing by BBMCSP—step 11, the NP-hard search step, is actually never called—. The same graph was proposed as benchmark in a recent Big Data Conference [1]. There it took 153 seconds to solve using 75 processor nodes!</p><p>Raw results of <a
href="http://venus.elai.upm.es/logs/results_sparse/bin/">BMCSP </a>against more than 200 real networks, as well as results of state-of-the-art algorithms are available <a
href="http://venus.elai.upm.es/logs/results_sparse/">here</a>. We are currently working on a heavy refactoring and a more sophisticated command line parameter interface both for Windows and Linux binaries. As always, we await comments and suggestions from readers.</p><p>&nbsp;</p><p>[1] Hagan, R. D. et al.; <em>Toward an Efficient, Highly Scalable Maximum Clique Solver for Massive Graphs</em>, IEEE Conf. on Big Data, 2014.</p><p>The post <a
rel="nofollow" href="http://blog.biicode.com/exact-maximum-clique-for-massive-real-graphs/">Exact maximum clique for large or massive real graphs continued</a> appeared first on <a
rel="nofollow" href="http://blog.biicode.com">biicode Blog</a>.</p> ]]></content:encoded> <wfw:commentRss>http://blog.biicode.com/exact-maximum-clique-for-massive-real-graphs/feed/</wfw:commentRss> <slash:comments>0</slash:comments> </item> </channel> </rss>